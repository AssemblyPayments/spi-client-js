{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./src/Messages.js","webpack:///./src/SpiModels.js","webpack:///./src/RequestIdHelper.js","webpack:///./src/SpiPayAtTable.js","webpack:///./src/PayAtTable.js","webpack:///./src/Preauth.js","webpack:///./src/SpiPreauth.js","webpack:///./src/Pairing.js","webpack:///./src/PosInfo.js","webpack:///./src/Purchase.js","webpack:///./src/Service/DeviceService.js","webpack:///./src/Spi.js","webpack:///./index.js"],"names":["root","factory","exports","module","define","amd","a","i","window","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Events","SuccessState","Unknown","Success","Failed","MessageStamp","posId","secrets","serverTimeDelta","_classCallCheck","this","PosId","Secrets","ServerTimeDelta","Message","id","eventName","data","needsEncryption","Id","EventName","Data","DateTimeStamp","IncommingHmac","_needsEncryption","DecryptedJson","_createClass","success","error_reason","error_detail","now","Date","dts","split","getTime","stamp","tzoffset","getTimezoneOffset","adjustedTime","toISOString","slice","envelope","message","event","datetime","pos_id","JSON","stringify","encMsg","Crypto","AesEncrypt","EncKey","encrMessageEnvelope","enc","hmac","HmacSignature","HmacKey","toUpperCase","bankDate","length","concat","substr","date","time","msgJson","env","parse","decryptedJson","AesDecrypt","decryptedMsg","IncomingHmac","e","msg","SpiStatus","SpiFlow","InitiateTxResult","initiated","SpiModels_classCallCheck","Initiated","TransactionFlowState","posRefId","type","amountCents","PosRefId","Type","DisplayMessage","AmountCents","RequestSent","RequestTime","LastStateRequestTime","AttemptingToCancel","AwaitingSignatureCheck","AwaitingPhoneForAuth","Finished","Response","SignatureRequiredMessage","PhoneForAuthRequiredMessage","CancelAttemptTime","Request","AwaitingGltResponse","GLTResponsePosRefId","SpiModels_createClass","response","spiMessage","state","SpiConfig","PromptForCustomerCopyOnEftpos","SignatureFlowOnEftpos","PrintMerchantCopy","messageData","prompt_for_customer_copy","print_for_signature_required_transactions","print_merchant_copy","__RequestIdHelperCounter","RequestIdHelper","RequestIdHelper_classCallCheck","RequestIdHelper_createClass","prefix","SpiPayAtTable","spi","SpiPayAtTable_classCallCheck","_spi","_log","console","Config","assign","PayAtTableConfig","PayAtTabledEnabled","OperatorIdEnabled","AllowedOperatorIds","EqualSplitEnabled","SplitByAmountEnabled","SummaryReportEnabled","TippingEnabled","LabelOperatorId","LabelPayButton","LabelTableId","SpiPayAtTable_createClass","billId","tableId","operatorId","Exception","billPayment","updatedBillData","_send","ToMessage","billStatus","GetBillStatus","TableId","TotalAmount","info","Result","BillRetrievalResult","INVALID_TABLE_ID","BillPayment","PayAtTable_classCallCheck","_incomingAdvice","BillId","OperatorId","pt","PaymentType","purchaseMsg","PurchaseResponse","PurchaseAmount","GetPurchaseAmount","TipAmount","GetTipAmount","existingBillStatus","SUCCESS","warn","existingPaymentHistory","getBillPaymentHistory","find","phe","GetTerminalRefId","GetTerminalReferenceId","updatedHistoryEntries","push","PaymentHistoryEntry","toLowerCase","ToPaymentSummary","BillStatusResponse","ToBillData","updatedBillStatus","BillPaymentReceived","BillData","PreauthEvents","AccountVerifyRequest","Preauth_classCallCheck","Preauth_createClass","pos_ref_id","PreauthOpenRequest","PreauthAmount","preauth_amount","PreauthTopupRequest","preauthId","topupAmountCents","PreauthId","TopupAmount","preauth_id","topup_amount","PreauthPartialCancellationRequest","partialCancellationAmountCents","PartialCancellationAmount","preauth_cancel_amount","PreauthExtendRequest","PreauthCancelRequest","PreauthCompletionRequest","completionAmountCents","surchargeAmount","CompletionAmount","SurchargeAmount","completion_amount","surcharge_amount","SpiPreauth","SpiPreauth_classCallCheck","SpiPreauth_createClass","verifyMsg","tfs","TransactionType","AccountVerify","_initiatePreauthTx","Preauth","toFixed","sentMsg","CurrentStatus","Unpaired","CurrentFlow","Idle","Transaction","CurrentTxFlowState","Sent","document","dispatchEvent","CustomEvent","detail","_handleAccountVerifyResponse","_handlePreauthResponse","incomingPosRefId","currentTxFlowState","Completed","GetSuccessState","lastIndexOf","DropKeysRequest","Pairing_classCallCheck","Pairing_createClass","SetPosInfoRequest","version","vendorId","libraryLanguage","libraryVersion","otherInfo","PosInfo_classCallCheck","_version","_vendorId","_libraryLanguage","_libraryVersion","_otherInfo","PosInfo_createClass","pos_version","pos_vendor_id","library_language","library_version","other_info","CancelTransactionRequest","Purchase_classCallCheck","Purchase_createClass","CancelTransactionResponse","_m","attribute","GetLastTransactionRequest","SignatureRequired","RequestId","_receiptToSign","merchant_receipt","requestId","receiptToSign","DeviceIpAddressService","serialNumber","apiKey","arguments","undefined","deviceIpUrl","fetch","method","headers","ASM-MSP-DEVICE-ADDRESS-API-KEY","then","json","catch","error","StatusCode","ErrorException","Spi","eftposAddress","deviceIpAddressRequest","Spi_classCallCheck","_posId","_secrets","_eftposAddress","_serialNumber","SerialNumber","_deviceApiKey","ApiKey","CurrentDeviceStatus","AutoIpResolutionEnable","_spiMessageStamp","_posVendorId","_posVersion","_hasSetInfo","_mostRecentPingSent","_mostRecentPongReceived","_missedPongsCount","_retrySinceLastDeviceIpAddressResolution","_mostRecentLoginResponse","_pongTimeout","_pingFrequency","_readyToTransact","_periodicPingThread","_txMonitorCheckFrequency","_checkOnTxFrequency","_maxWaitForCancelTx","_missedPongsToDisconnect","_retryBeforeResolvingDeviceIpAddress","CurrentPairingFlowState","_currentStatus","_spiPat","_spiPreauth","Warn","_resetConn","_startTransactionMonitoringThread","_conn","Connect","address","Address","ResolveDeviceIpAddress","posVendorId","posVersion","PairingFlowState","AwaitingCheckFromEftpos","AwaitingCheckFromPos","ConfirmationCode","Successful","_onPairingSuccess","_onReadyToTransact","_onPairingFailed","_doUnpair","purchaseRequest","PurchaseHelper","CreatePurchaseRequest","Purchase","purchaseAmount","tipAmount","cashoutAmount","promptForCashout","options","purchase","CreatePurchaseRequestV2","Options","AmountSummary","isSuppressMerchantPassword","refundRequest","CreateRefundRequest","refundMsg","Refund","accepted","MidTxResult","SignatureResponded","SignatureAccept","SignatureDecline","authCode","SubmitAuthCodeResult","AuthCodeSent","AuthCodeAdvice","cancelReq","Cancelling","cashoutOnlyRequest","CashoutOnlyRequest","cashoutMsg","CashoutOnly","motoPurchaseRequest","MotoPurchaseRequest","MOTO","settleRequestMsg","SettleRequest","Settle","stlEnqMsg","SettlementEnquiryRequest","SettlementEnquiry","gltRequestMsg","GetLastTransaction","txType","gltResponse","GltMatch","Error","GetPosRefId","payload","PrintingRequest","toMessage","TerminalStatusRequest","result","PairingHelper","GenerateSecretsAndKeyResponse","KeyRequest","KeyResponse","keyCheck","KeyCheck","pairResp","PairResponse","_startPeriodicPing","Info","Disconnect","krRes","KeyRollingHelper","PerformKeyRolling","NewSecrets","KeyRollingConfirmation","phoneForAuthRequired","PhoneForAuthRequired","GetPhoneNumber","GetMerchantId","GetError","_callGetLastTransaction","txState","GotGltResponse","gtlResponse","GetLastTransactionResponse","WasRetrievedSuccessfully","CopyMerchantReceiptToCustomerReceipt","successState","UnknownCompleted","IsStillInProgress","IsWaitingForSignatureResponse","IsWaitingForAuthCode","WasTimeOutOfSyncError","cancelResponse","GetErrorReason","GetErrorDetail","CancelFailed","SetPosInfoResponse","isSuccess","getErrorReason","getErrorDetail","_this","needsPublishing","CallingGlt","setTimeout","PrintingResponse","TerminalStatusResponse","BatteryLevelChanged","_this2","Connection","addEventListener","_onSpiConnectionStatusChanged","_onSpiMessageReceived","_onWsErrorReceived","_this3","ConnectionState","Connecting","Connected","pr","NewPairRequest","Disconnected","_stopPeriodicPing","_this4","setInterval","_periodicPing","_this5","_doPing","_callSetPosInfo","PushPayAtTableConfig","setPosInfoRequest","GetVersion","DeviceInfo","GetAppDeviceInfo","clearInterval","ping","PingHelper","GeneratePingRequest","_mostRecentPingSentTime","GetServerTimeDelta","debug","pong","PongHelper","GeneratePongRessponse","gltRequest","messageJson","FromJson","IsPreauthEvent","_handlePreauthMessage","_handleKeyRequest","_handleKeyCheck","_handlePairResponse","_handleDropKeysAdvice","_handlePurchaseResponse","_handleRefundResponse","_handleCashoutOnlyResponse","_handleMotoPurchaseResponse","_handleSignatureRequired","_handleAuthCodeRequired","_handleGetLastTransactionResponse","HandleSettleResponse","_handleSettlementEnquiryResponse","_handleIncomingPing","_handleIncomingPong","_handleKeyRollingRequest","_handleCancelTransactionResponse","_handleSetPosInfoResponse","FeatureDisableMessage","_handleGetTableConfig","_handleGetBillDetailsRequest","_handleBillPaymentAdvice","_handlePrintingResponse","_handleTerminalStatusResponse","_handleBatteryLevelChanged","_handleErrorEvent","ToJson","Send","_this6","RetrieveService","ip","Ip","DeviceIpAddressStatus","last_updated","DeviceService_classCallCheck","Last_updated"],"mappings":"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","file":"spi-client-js.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","// <summary>\n// Events statically declares the various event names in messages.\n// </summary>\nexport const Events = {\n     PairRequest : \"pair_request\",\n     KeyRequest : \"key_request\",\n     KeyResponse : \"key_response\",\n     KeyCheck : \"key_check\",\n     PairResponse : \"pair_response\",\n     DropKeysAdvice : \"drop_keys\",\n\n     LoginRequest : \"login_request\",\n     LoginResponse : \"login_response\",\n\n     Ping : \"ping\",\n     Pong : \"pong\",\n\n     PurchaseRequest : \"purchase\",\n     PurchaseResponse : \"purchase_response\",\n     CancelTransactionRequest : \"cancel_transaction\",\n     CancelTransactionResponse : \"cancel_response\",\n     GetLastTransactionRequest : \"get_last_transaction\",\n     GetLastTransactionResponse : \"last_transaction\",\n     RefundRequest : \"refund\",\n     RefundResponse : \"refund_response\",\n     SignatureRequired : \"signature_required\",\n     SignatureDeclined : \"signature_decline\",\n     SignatureAccepted : \"signature_accept\",\n     AuthCodeRequired : \"authorisation_code_required\",\n     AuthCodeAdvice : \"authorisation_code_advice\",\n\n     CashoutOnlyRequest : \"cash\",\n     CashoutOnlyResponse : \"cash_response\",\n\n     MotoPurchaseRequest : \"moto_purchase\",\n     MotoPurchaseResponse : \"moto_purchase_response\",\n\n     SettleRequest : \"settle\",\n     SettleResponse : \"settle_response\",\n     SettlementEnquiryRequest : \"settlement_enquiry\",\n     SettlementEnquiryResponse : \"settlement_enquiry_response\",\n\n     SetPosInfoRequest : \"set_pos_info\",\n     SetPosInfoResponse : \"set_pos_info_response\",\n\n     KeyRollRequest : \"request_use_next_keys\",\n     KeyRollResponse : \"response_use_next_keys\",\n\n     Error : \"error\",\n    \n     InvalidHmacSignature : \"_INVALID_SIGNATURE_\",\n\n    // Pay At Table Related Messages\n    PayAtTableGetTableConfig : \"get_table_config\", // incoming. When eftpos wants to ask us for P@T configuration.\n    PayAtTableSetTableConfig : \"set_table_config\", // outgoing. When we want to instruct eftpos with the P@T configuration.\n    PayAtTableGetBillDetails : \"get_bill_details\", // incoming. When eftpos wants to aretrieve the bill for a table.\n    PayAtTableBillDetails : \"bill_details\",        // outgoing. We reply with this when eftpos requests to us get_bill_details.\n    PayAtTableBillPayment : \"bill_payment\",        // incoming. When the eftpos advices \n\n    PrintingRequest : \"print\",\n    PrintingResponse : \"print_response\",\n\n    TerminalStatusRequest : \"get_terminal_status\",\n    TerminalStatusResponse : \"terminal_status\",\n\n    BatteryLevelChanged : \"battery_level_changed\"\n};\n\nexport const SuccessState = {\n    Unknown: 'Unknown', Success: 'Success', Failed: 'Failed'\n};\n\n// <summary>\n// MessageStamp represents what is required to turn an outgoing Message into Json\n// including encryption and date setting.\n// </summary>\nexport class MessageStamp {\n    constructor(posId, secrets, serverTimeDelta) {\n        this.PosId = posId;\n        this.Secrets = secrets;\n        this.ServerTimeDelta = serverTimeDelta;\n    }\n}\n\n// <summary>\n// MessageEnvelope represents the outer structure of any message that is exchanged\n// between the Pos and the PinPad and vice-versa.\n// See http://www.simplepaymentapi.com/#/api/message-encryption\n// </summary>\nexport class MessageEnvelope {\n    constructor(message, enc, hmac, posId) {\n        // <summary>\n        // The Message field is set only when in Un-encrypted form.\n        // In fact it is the only field in an envelope in the Un-Encrypted form.\n        // </summary>\n        this.Message = message;\n\n        // <summary>\n        // The enc field is set only when in Encrypted form.\n        // It contains the encrypted Json of another MessageEnvelope \n        // </summary>\n        this.Enc = enc;\n\n        // <summary>\n        // The hmac field is set only when in Encrypted form.\n        // It is the signature of the \"enc\" field.\n        // </summary>\n        this.Hmac = hmac;\n\n        // <summary>\n        // The pos_id field is only filled for outgoing Encrypted messages.\n        // </summary>\n        this.PosId = posId;\n    }\n\n    toJSON() {\n        return {\n            message: this.Message,\n            enc: this.Enc,\n            hmac: this.Hmac,\n            pos_id: this.PosId\n        }\n    }\n}\n\n// <summary>\n// Message represents the contents of a Message.\n// See http://www.simplepaymentapi.com/#/api/message-encryption\n// </summary>\nexport class Message {\n    constructor(id, eventName, data, needsEncryption) {\n        this.Id = id;\n        this.EventName = eventName;\n        this.Data = data;\n        this.DateTimeStamp = '';\n        this.PosId = ''; // Pos_id is set here only for outgoing Un-encrypted messages. \n        this.IncommingHmac = ''; // Sometimes the logic around the incoming message might need access to the sugnature, for example in the key_check.\n        this._needsEncryption = needsEncryption; // Denotes whether an outgoing message needs to be encrypted in ToJson()\n        this.DecryptedJson = ''; // Set on an incoming message just so you can have a look at what it looked like in its json form.\n    }\n\n    GetSuccessState() {\n        if(!this.Data || typeof this.Data.success === \"undefined\") {\n            return SuccessState.Unknown;\n        }\n\n        return this.Data.success ? SuccessState.Success : SuccessState.Failed;\n    }\n\n    GetError() {\n        return this.Data.error_reason ? this.Data.error_reason : \"\";\n    }\n\n    GetErrorDetail() {\n        return this.Data.error_detail;\n    }\n\n    GetServerTimeDelta()\n    {\n        let now = Date.now();\n        \n        // Stamp format: 2018-04-19T01:42:38.279\n        let dts = this.DateTimeStamp.split(/[\\-\\+\\. :T]/);\n        let msgTime = new Date(\n            // year, month, date\n            dts[0], dts[1] - 1, dts[2],\n            // hour, minute, second, millis\n            dts[3], dts[4], dts[5], dts[6]\n        ).getTime(); // Local time zone\n\n        return msgTime - now;\n    }\n\n    // Helper method to parse bank date format 20042018 (ddMMyyyy)\n    static ParseBankDate(bankDate) {\n        if(bankDate.length !== 8) return null;\n\n        return new Date(`${bankDate.substr(4,4)}-${bankDate.substr(2,2)}-${bankDate.substr(0,2)}`);\n    }\n\n    // Parses a bank date & time str from \"05Oct17\" / \"05:00\" (\"ddMMMyy/HH:mm\") into date obj\n    static ParseBankDateTimeStr(date, time) {\n        return new Date(`${date.substr(0,2)} ${date.substr(2,3)} ${date.substr(5,2)} ${time}`);\n    }\n\n    static FromJson(msgJson, secrets) {\n        let env = JSON.parse(msgJson);\n\n        if(env.message != null) {\n            let message = new Message(env.message.id, env.message.event, env.message.data, false);\n            message.DecryptedJson = msgJson;\n            return message;\n        }\n\n        if (secrets == null)\n        {\n            // This may happen if we somehow received an encrypted message from eftpos but we're not configered with secrets.\n            // For example, if we cancel the pairing process a little late in the game and we get an encrypted key_check message after we've dropped the keys.\n            return new Message(\"UNKNOWN\", \"NOSECRETS\", null, false);\n        }\n\n        // Its encrypted, verify sig\n        let sig = Crypto.HmacSignature(secrets.HmacKey, env.enc);\n        if (sig.toUpperCase() != env.hmac) {\n            return new Message(\"_\", Events.InvalidHmacSignature, null, false);\n        }\n\n        let decryptedJson = Crypto.AesDecrypt(secrets.EncKey, env.enc);\n\n        try {\n            let decryptedMsg = JSON.parse(decryptedJson);\n\n            let message = new Message(decryptedMsg.message.id, decryptedMsg.message.event, decryptedMsg.message.data, true);\n\n            message.DateTimeStamp = decryptedMsg.message.datetime;\n            message.PosId = decryptedMsg.message.pos_id;\n            message.IncomingHmac = env.hmac; \n            message.DecryptedJson = decryptedJson;\n\n            return message;\n\n        } catch(e) {\n            return new Message(\"UNKNOWN\", \"UNPARSEABLE\", {\"msg\": decryptedJson}, false);\n        }\n    }\n\n    ToJson(stamp) {\n        let now = Date.now();\n        let tzoffset = new Date().getTimezoneOffset() * 60 * 1000;\n        let adjustedTime = new Date(now - tzoffset + stamp.ServerTimeDelta);\n\n        // Format date: \"yyyy-MM-ddTHH:mm:ss.fff\"\n        this.DateTimeStamp = adjustedTime.toISOString().slice(0,-1);\n        this.PosId = stamp.PosId;\n        \n        var envelope = {\n            message: {\n                id: this.Id,\n                event: this.EventName,\n                data: this.Data,\n                datetime: this.DateTimeStamp\n            }\n        };\n\n        if (!this._needsEncryption) {\n            // Unencrypted Messages need PosID inside the message\n            envelope.message.pos_id = this.PosId\n        }\n        this.DecryptedJson = JSON.stringify(envelope);\n\n        if (!this._needsEncryption) {\n            return this.DecryptedJson;\n        }\n\n        let encMsg = Crypto.AesEncrypt(stamp.Secrets.EncKey, this.DecryptedJson);\n        let hmacSig = Crypto.HmacSignature(stamp.Secrets.HmacKey, encMsg);\n        let encrMessageEnvelope = {enc: encMsg, hmac: hmacSig.toUpperCase(), pos_id: stamp.PosId};\n\n        return JSON.stringify(encrMessageEnvelope);\n    }\n}\n","import {SuccessState} from './Messages';\n\n// <summary>\n// Represents the 3 Pairing statuses that the Spi instanxce can be in.\n// </summary>\nexport const SpiStatus = \n{\n    // <summary>\n    // Paired and Connected\n    // </summary>\n    PairedConnected: 'PairedConnected',\n    \n    // <summary>\n    // Paired but trying to establish a connection \n    // </summary>\n    PairedConnecting: 'PairedConnecting',\n    \n    // <summary>\n    // Unpaired\n    // </summary>\n    Unpaired: 'Unpaired'\n};\n\n// <summary>\n// The Spi instance can be in one of these flows at any point in time.\n// </summary>\nexport const SpiFlow = \n{\n    // <summary>\n    // Currently going through the Pairing Process Flow.\n    // Happens during the Unpaired SpiStatus.\n    // </summary>\n    Pairing: 'Pairing',\n    \n    // <summary>\n    // Currently going through the transaction Process Flow.\n    // Cannot happen in the Unpaired SpiStatus.\n    // </summary>\n    Transaction: 'Transaction',\n\n    // <summary>\n    // Not in any of the other states.\n    // </summary>\n    Idle: 'Idle'\n};\n\n// <summary>\n// Represents the Pairing Flow State during the pairing process \n// </summary>\nexport class PairingFlowState\n{\n    constructor(state) {\n        // <summary>\n        // Some text that can be displayed in the Pairing Process Screen\n        // that indicates what the pairing process is up to.\n        // </summary>\n        this.Message = null;\n\n        // <summary>\n        // When true, it means that the EFTPOS is shoing the confirmation code,\n        // and your user needs to press YES or NO on the EFTPOS.\n        // </summary>\n        this.AwaitingCheckFromEftpos = null;\n        \n        // <summary>\n        // When true, you need to display the YES/NO buttons on you pairing screen\n        // for your user to confirm the code.\n        // </summary>\n        this.AwaitingCheckFromPos = null;\n        \n        // <summary>\n        // This is the confirmation code for the pairing process.\n        // </summary>\n        this.ConfirmationCode = null;\n        \n        // <summary>\n        // Indicates whether the Pairing Flow has finished its job.\n        // </summary>\n        this.Finished = null;\n        \n        // <summary>\n        // Indicates whether pairing was successful or not.\n        // </summary>\n        this.Successful = null;\n\n        if(state) {\n            Object.assign(this, state);\n        }\n    }   \n}\n\nexport const TransactionType = \n{\n    Purchase: 'Purchase',\n    Refund: 'Refund',\n    CashoutOnly: 'CashoutOnly',\n    MOTO: 'MOTO',\n    Settle: 'Settle',\n    SettlementEnquiry: 'SettlementEnquiry',\n    GetLastTransaction: 'GetLastTransaction',\n    \n    Preauth: 'Preauth',\n    AccountVerify: 'AccountVerify'\n};\n\n// <summary>\n// Used as a return in the InitiateTx methods to signify whether \n// the transaction was initiated or not, and a reason to go with it.\n// </summary>\nexport class InitiateTxResult\n{\n    constructor(initiated, message)\n    {\n        // <summary>\n        // Whether the tx was initiated.\n        // When true, you can expect updated to your registered callback.\n        // When false, you can retry calling the InitiateX method.\n        // </summary>\n        this.Initiated = initiated;\n\n        // <summary>\n        // Text that gives reason for the Initiated flag, especially in case of false. \n        // </summary>\n        this.Message = message;\n    }\n}\n\n// <summary>\n// Used as a return in calls mid transaction to let you know\n// whether the call was valid or not.\n// These attributes work for COM interop.\n// </summary>\nexport class MidTxResult\n{\n    // <summary>\n    // This default stucture works for COM interop.\n    // </summary>\n    constructor(valid, message)\n    {\n        this.Valid = valid;\n        this.Message = message;\n    }\n}    \n\n// <summary>\n// Represents the State during a TransactionFlow\n// </summary>\nexport class TransactionFlowState\n{\n    constructor(posRefId, type, amountCents, message, msg)\n    {\n        // <summary>\n        //  The id given to this transaction\n        // </summary>\n        this.PosRefId   = posRefId;\n        this.Id         = posRefId; // obsolete, but let's maintain it for now, to mean same as PosRefId.\n\n        // <summary>\n        // Purchase/Refund/Settle/...\n        // </summary>\n        this.Type = type;\n\n        // <summary>\n        // A text message to display on your Transaction Flow Screen\n        // </summary>\n        this.DisplayMessage = msg;\n\n        // <summary>\n        // Amount in cents for this transaction\n        // </summary>\n        this.AmountCents = amountCents;\n\n        // <summary>\n        // Whther the request has been sent to the EFTPOS yet or not.\n        // In the PairedConnecting state, the transaction is initiated\n        // but the request is only sent once the connection is recovered.\n        // </summary>\n        this.RequestSent = false;\n\n        // <summary>\n        // The time when the request was sent to the EFTPOS.\n        // </summary>\n        this.RequestTime = null;\n                \n        // <summary>\n        // The time when we last asked for an update, including the original request at first\n        // </summary>\n        this.LastStateRequestTime = null;\n        \n        // <summary>\n        // Whether we're currently attempting to Cancel the transaction.\n        // </summary>\n        this.AttemptingToCancel = null;\n    \n        // <summary>\n        // When this flag is on, you need to display the dignature accept/decline buttons in your \n        // transaction flow screen.\n        // </summary>\n        this.AwaitingSignatureCheck = false;\n\n        // <summary>\n        // When this flag is on, you need to show your user the phone number to call to get the authorisation code.\n        // Then you need to provide your user means to enter that given code and submit it via SubmitAuthCode().\n        // </summary>\n        this.AwaitingPhoneForAuth = null;\n\n        // <summary>\n        // Whether this transaction flow is over or not.\n        // </summary>\n        this.Finished = false;\n\n        // <summary>\n        // The success state of this transaction. Starts off as Unknown.\n        // When finished, can be Success, Failed OR Unknown.\n        // </summary>\n        this.Success = SuccessState.Unknown;\n\n        // <summary>\n        // The response at the end of the transaction. \n        // Might not be present in all edge cases.\n        // You can then turn this Message into the appropriate structure,\n        // such as PurchaseResponse, RefundResponse, etc\n        // </summary>\n        this.Response = null;\n\n        // <summary>\n        // The message the we received from EFTPOS that told us that signature is required.\n        // </summary>\n        this.SignatureRequiredMessage = null;\n    \n        // <summary>\n        // The message the we received from EFTPOS that told us that Phone For Auth is required.\n        // </summary>\n        this.PhoneForAuthRequiredMessage = null;\n\n        // <summary>\n        // The time when the cancel attempt was made.\n        // </summary>\n        this.CancelAttemptTime = null;\n\n        // <summary>\n        // The request message that we are sending/sent to the server.\n        // </summary>\n        this.Request = message;\n\n        // <summary>\n        // Whether we're currently waiting for a Get Last Transaction Response to get an update. \n        // </summary>\n        this.AwaitingGltResponse = null;\n\n        this.GLTResponsePosRefId = null;\n    }\n\n    Sent(msg)\n    {\n        this.RequestSent = true;\n        this.RequestTime = Date.now();\n        this.LastStateRequestTime = Date.now();\n        this.DisplayMessage = msg;\n    }\n\n    Cancelling(msg)\n    {\n        this.AttemptingToCancel = true;\n        this.CancelAttemptTime = Date.now();\n        this.DisplayMessage = msg;\n    }\n\n    CancelFailed(msg)\n    {\n        this.AttemptingToCancel = false;\n        this.DisplayMessage = msg;\n    }\n\n    CallingGlt()\n    {\n        this.AwaitingGltResponse = true;\n        this.LastStateRequestTime = Date.now();\n    }\n\n    GotGltResponse()\n    {\n        this.AwaitingGltResponse = false;\n    }\n    \n    Failed(response, msg)\n    {\n        this.Success = SuccessState.Failed;\n        this.Finished = true;\n        this.Response = response;\n        this.DisplayMessage = msg;\n    }\n\n    SignatureRequired(spiMessage, msg)\n    {\n        this.SignatureRequiredMessage = spiMessage;\n        this.AwaitingSignatureCheck = true;\n        this.DisplayMessage = msg;\n    }\n\n    SignatureResponded(msg)\n    {\n        this.AwaitingSignatureCheck = false;\n        this.DisplayMessage = msg;\n    }\n    \n    PhoneForAuthRequired(spiMessage, msg)\n    {\n        this.PhoneForAuthRequiredMessage = spiMessage;\n        this.AwaitingPhoneForAuth = true;\n        this.DisplayMessage = msg;\n    }\n    \n    AuthCodeSent(msg)\n    {\n        this.AwaitingPhoneForAuth = false;\n        this.DisplayMessage = msg;\n    }\n\n    Completed(state, response, msg)\n    {\n        this.Success = state;\n        this.Response = response;\n        this.Finished = true;\n        this.AttemptingToCancel = false;\n        this.AwaitingGltResponse = false;\n        this.AwaitingSignatureCheck = false;\n        this.AwaitingPhoneForAuth = false;\n        this.DisplayMessage = msg;\n    }\n\n    UnknownCompleted(msg)\n    {\n        this.Success = SuccessState.Unknown;\n        this.Response = null;\n        this.Finished = true;\n        this.AttemptingToCancel = false;\n        this.AwaitingGltResponse = false;\n        this.AwaitingSignatureCheck = false;\n        this.AwaitingPhoneForAuth = false;\n        this.DisplayMessage = msg;\n    }\n}\n\n// <summary>\n// Used as a return in the SubmitAuthCode method to signify whether Code is valid\n// </summary>\nexport class SubmitAuthCodeResult\n{\n    constructor(validFormat, message)\n    {\n        this.ValidFormat = validFormat;\n\n        // <summary>\n        // Text that gives reason for Invalidity\n        // </summary>\n        this.Message = message;\n    }\n}\n\nexport class SpiConfig\n{\n    constructor() {\n        this.PromptForCustomerCopyOnEftpos  = false;\n        this.SignatureFlowOnEftpos          = false;\n        this.PrintMerchantCopy              = false;\n    }\n\n    addReceiptConfig(messageData)\n    {\n        if (this.PromptForCustomerCopyOnEftpos)\n        {\n            messageData.prompt_for_customer_copy = this.PromptForCustomerCopyOnEftpos;\n        }\n        if (this.SignatureFlowOnEftpos)\n        {\n            messageData.print_for_signature_required_transactions = this.SignatureFlowOnEftpos;\n        }\n        if (this.PrintMerchantCopy)\n        {\n            messageData.print_merchant_copy = this.PrintMerchantCopy;\n        }\n        return messageData;\n    }\n\n    ToString()\n    {\n        return `PromptForCustomerCopyOnEftpos:${this.PromptForCustomerCopyOnEftpos} SignatureFlowOnEftpos:${this.SignatureFlowOnEftpos} PrintMerchantCopy: ${this.PrintMerchantCopy}`;\n    }\n}\n\nexport class TransactionOptions\n{\n    constructor() {\n        this._customerReceiptHeader = null;\n        this._customerReceiptFooter = null;\n        this._merchantReceiptHeader = null;\n        this._merchantReceiptFooter = null;\n    }\n\n    SetCustomerReceiptHeader(customerReceiptHeader)\n    {\n        this._customerReceiptHeader = customerReceiptHeader;\n    }\n\n    SetCustomerReceiptFooter(customerReceiptFooter)\n    {\n        this._customerReceiptFooter = customerReceiptFooter;\n    }\n    SetMerchantReceiptHeader(merchantReceiptHeader)\n    {\n        this._merchantReceiptHeader = merchantReceiptHeader;\n    }\n    SetMerchantReceiptFooter(merchantReceiptFooter)\n    {\n        this._merchantReceiptFooter = merchantReceiptFooter;\n    }\n    AddOptions(messageData)\n    {\n        messageData.customer_receipt_header = this._customerReceiptHeader;\n        messageData.customer_receipt_footer = this._customerReceiptFooter;\n        messageData.merchant_receipt_header = this._merchantReceiptHeader;\n        messageData.merchant_receipt_footer = this._merchantReceiptFooter;\n\n        return messageData;\n    }\n}","let __RequestIdHelperCounter = 1;\n\nexport class RequestIdHelper {\n    static Id(prefix) {\n        return prefix + __RequestIdHelperCounter++;\n    }\n}\n","import {RequestIdHelper} from './RequestIdHelper';\nimport {BillPayment} from './PayAtTable';\n\nexport class SpiPayAtTable\n{  \n    constructor(spi)\n    {\n        this._spi = spi;\n        this._log = console;\n\n        this.Config = Object.assign(new PayAtTableConfig(), {\n            PayAtTabledEnabled: true,\n            OperatorIdEnabled: true,\n            AllowedOperatorIds: [],\n            EqualSplitEnabled: true,\n            SplitByAmountEnabled: true,\n            SummaryReportEnabled: true,\n            TippingEnabled: true,\n            LabelOperatorId: \"Operator ID\",\n            LabelPayButton: \"Pay at Table\",\n            LabelTableId: \"Table Number\"\n        });\n    }\n\n    // <summary>\n    // This delegate will be called when the Eftpos needs to know the current state of a bill for a table. \n    // <para />\n    // Parameters:<para />\n    // billId - The unique identifier of the bill. If empty, it means that the PayAtTable flow on the Eftpos is just starting, and the lookup is by tableId.<para />\n    // tableId - The identifier of the table that the bill is for. <para />\n    // operatorId - The id of the operator entered on the eftpos. <para />\n    // <para />\n    // Return:<para />\n    // You need to return the current state of the bill.\n    // </summary>\n    GetBillStatus(billId, tableId, operatorId) {\n        throw new Exception('Method not implemented. Please overwrite this method in your POS');\n    }\n\n    // Abstract method, must implement in POS system\n    BillPaymentReceived(billPayment, updatedBillData) {\n        throw new Exception('Method not implemented. Please overwrite this method in your POS');\n    }\n\n    PushPayAtTableConfig()\n    {\n        this._spi._send(this.Config.ToMessage(RequestIdHelper.Id(\"patconf\")));\n    } \n    \n    _handleGetBillDetailsRequest(m)\n    {\n        var operatorId = m.Data[\"operator_id\"];\n        var tableId = m.Data[\"table_id\"];\n\n        // Ask POS for Bill Details for this tableId, inluding encoded PaymentData\n        var billStatus = this.GetBillStatus(null, tableId, operatorId);\n        billStatus.TableId = tableId;\n        if (billStatus.TotalAmount <= 0)\n        {\n            this._log.info(\"Table has 0 total amount. not sending it to eftpos.\");\n            billStatus.Result = BillRetrievalResult.INVALID_TABLE_ID;\n        }\n        \n        this._spi._send(billStatus.ToMessage(m.Id));\n    }\n\n    _handleBillPaymentAdvice(m)\n    {\n        var billPayment = new BillPayment(m);\n        \n        // Ask POS for Bill Details, inluding encoded PaymentData\n        var existingBillStatus = this.GetBillStatus(billPayment.BillId, billPayment.TableId, billPayment.OperatorId);\n        if (existingBillStatus.Result != BillRetrievalResult.SUCCESS)\n        {\n            this._log.warn(\"Could not retrieve Bill Status for Payment Advice. Sending Error to Eftpos.\");\n            this._spi._send(existingBillStatus.ToMessage(m.Id));\n        }\n                    \n        var existingPaymentHistory = existingBillStatus.getBillPaymentHistory();\n   \n        var foundExistingEntry = existingPaymentHistory.find(phe => phe.GetTerminalRefId() == billPayment.PurchaseResponse.GetTerminalReferenceId());\n        if (foundExistingEntry)\n        {\n            // We have already processed this payment.\n            // perhaps Eftpos did get our acknowledgement.\n            // Let's update Eftpos.\n            this._log.warn(\"Had already received this bill_paymemnt advice from eftpos. Ignoring.\");\n            this._spi._send(existingBillStatus.ToMessage(m.Id));\n            return;\n        }\n\n        // Let's add the new entry to the history\n        var updatedHistoryEntries = existingPaymentHistory;\n        updatedHistoryEntries.push(\n            new PaymentHistoryEntry(billPayment.PaymentType.toLowerCase(), billPayment.PurchaseResponse.ToPaymentSummary())\n        );\n        \n        var updatedBillData = BillStatusResponse.ToBillData(updatedHistoryEntries);\n\n        // Advise POS of new payment against this bill, and the updated BillData to Save.\n        var updatedBillStatus = this.BillPaymentReceived(billPayment, updatedBillData);\n\n        // Just in case client forgot to set these:\n        updatedBillStatus.BillId = billPayment.BillId;\n        updatedBillStatus.TableId = billPayment.TableId;\n\n        if (updatedBillStatus.Result != BillRetrievalResult.SUCCESS)\n        {\n            this._log.warn(\"POS Errored when being Advised of Payment. Letting EFTPOS know, and sending existing bill data.\");\n            updatedBillStatus.BillData = existingBillStatus.BillData;\n        }\n        else\n        {\n            updatedBillStatus.BillData = updatedBillData;\n        }\n    \n        this._spi._send(updatedBillStatus.ToMessage(m.Id));\n    }\n    \n    _handleGetTableConfig(m)\n    {\n        this._spi._send(this.Config.ToMessage(m.Id));\n    }\n}\n","import {Events} from './Messages';\n\n// <summary>\n// This class represents the BillDetails that the POS will be asked for throughout a PayAtTable flow.\n// </summary>\nexport class BillStatusResponse\n{\n    constructor() {\n        // <summary>\n        // Set this Error accordingly if you are not able to return the BillDetails that were asked from you.\n        // </summary>\n        this.Result = null;\n        \n        // <summary>\n        // This is a unique identifier that you assign to each bill.\n        // It migt be for example, the timestamp of when the cover was opened.\n        // </summary>\n        this.BillId = null;\n        \n        // <summary>\n        // This is the table id that this bill was for.\n        // The waiter will enter it on the Eftpos at the start of the PayAtTable flow and the Eftpos will \n        // retrieve the bill using the table id. \n        // </summary>\n        this.TableId = null;\n        \n        // <summary>\n        // The Total Amount on this bill, in cents.\n        // </summary>\n        this.TotalAmount = 0;\n        \n        // <summary>\n        // The currently outsanding amount on this bill, in cents.\n        // </summary>\n        this.OutstandingAmount = 0;\n\n        // <summary>\n        // Your POS is required to persist some state on behalf of the Eftpos so the Eftpos can recover state.\n        // It is just a piece of string that you save against your billId.\n        // WHenever you're asked for BillDetails, make sure you return this piece of data if you have it.\n        // </summary>\n        this.BillData = \"\";\n    }\n\n    getBillPaymentHistory()\n    {\n        if (!this.BillData)\n        {\n            return [];\n        }\n        \n        let billPaymentHistory = [];\n        let savedBillData = JSON.parse(this.BillData);\n\n        return savedBillData.map((bill) => {\n            return new PaymentHistoryEntry(bill.payment_type, bill.payment_summary);\n        });\n    }\n\n    static ToBillData(ph)\n    {\n        if (ph.length < 1)\n        {\n            return \"\";\n        }\n\n        return JSON.stringify(ph);\n    }\n    \n    ToMessage(messageId)\n    {\n        var data = {\n            \"success\": this.Result==BillRetrievalResult.SUCCESS\n        };\n        \n        if (this.BillId) data.bill_id = this.BillId;\n        if (this.TableId) data.table_id = this.TableId;\n\n        if (this.Result == BillRetrievalResult.SUCCESS)\n        {\n            data.bill_total_amount = this.TotalAmount;\n            data.bill_outstanding_amount = this.OutstandingAmount;\n            data.bill_payment_history = this.getBillPaymentHistory();\n        }\n        else\n        {\n            data.error_reason = this.Result.toString();\n            data.error_detail = this.Result.toString();\n        }\n\n        return new Message(messageId, Events.PayAtTableBillDetails, data, true);\n    }\n}\n\nexport const BillRetrievalResult = \n{\n    SUCCESS: 'SUCCESS',\n    INVALID_TABLE_ID: 'INVALID_TABLE_ID',\n    INVALID_BILL_ID: 'INVALID_BILL_ID',\n    INVALID_OPERATOR_ID: 'INVALID_OPERATOR_ID'\n};\n\nexport const PaymentType = \n{\n    CARD: 'CARD',\n    CASH: 'CASH' \n};\n\nexport class BillPayment\n{\n    constructor(m)\n    {\n        this._incomingAdvice = m;\n        this.BillId = this._incomingAdvice.Data[\"bill_id\"];\n        this.TableId = this._incomingAdvice.Data[\"table_id\"];\n        this.OperatorId = this._incomingAdvice.Data[\"operator_id\"];\n        \n        var pt = this._incomingAdvice.Data[\"payment_type\"];\n        this.PaymentType = pt;\n        \n        // this is when we ply the sub object \"payment_details\" into a purchase response for convenience.\n        var purchaseMsg = new Message(m.Id, \"payment_details\", m.Data[\"payment_details\"], false);\n        this.PurchaseResponse = new PurchaseResponse(purchaseMsg);\n\n        this.PurchaseAmount = this.PurchaseResponse.GetPurchaseAmount();\n        this.TipAmount = this.PurchaseResponse.GetTipAmount();\n    }\n}\n\nexport class PaymentHistoryEntry\n{\n    constructor(paymentType, paymentSummary)\n    {\n        this.PaymentType = paymentType;\n        this.PaymentSummary = paymentSummary;\n    }\n\n    toJSON() {\n        return {\n            payment_type: this.PaymentType,\n            payment_summary: this.PaymentSummary\n        };\n    }\n    \n    GetTerminalRefId()\n    {\n        return this.PaymentSummary[\"terminal_ref_id\"];\n    }\n}\n\nexport class PayAtTableConfig\n{\n    constructor() {\n        this.PayAtTabledEnabled = false;\n        this.OperatorIdEnabled = false;\n        this.SplitByAmountEnabled = false;\n        this.EqualSplitEnabled = false;\n    \n        this.TippingEnabled = false;\n    \n        this.SummaryReportEnabled = false;\n    \n        this.LabelPayButton = '';\n        this.LabelOperatorId = '';\n        this.LabelTableId = '';\n    \n        // \n        // <summary>\n        // Fill in with operator ids that the eftpos terminal will validate against. \n        // Leave Empty to allow any operator_id through. \n        // </summary>\n       this.AllowedOperatorIds = [];\n    }\n\n    ToMessage(messageId)\n    {\n        var data = {\n            \"pay_at_table_enabled\": this.PayAtTabledEnabled,\n            \"operator_id_enabled\": this.OperatorIdEnabled,\n            \"split_by_amount_enabled\": this.SplitByAmountEnabled,\n            \"equal_split_enabled\": this.EqualSplitEnabled,\n            \"tipping_enabled\": this.TippingEnabled,\n            \"summary_report_enabled\": this.SummaryReportEnabled,\n            \"pay_button_label\": this.LabelPayButton,\n            \"operator_id_label\": this.LabelOperatorId,\n            \"table_id_label\": this.LabelTableId,\n            \"operator_id_list\": this.AllowedOperatorIds\n        };\n\n        return new Message(messageId, Events.PayAtTableSetTableConfig, data, true);\n    }\n    \n    static FeatureDisableMessage(messageId) {\n        var data = {\n            \"pay_at_table_enabled\": false\n        };\n        return new Message(messageId, Events.PayAtTableSetTableConfig, data, true);\n    }\n}\n\n    ","import {RequestIdHelper} from './RequestIdHelper';\n\nexport const PreauthEvents = \n{\n    AccountVerifyRequest: \"account_verify\",\n    AccountVerifyResponse: \"account_verify_response\",\n    \n    PreauthOpenRequest : \"preauth\",\n    PreauthOpenResponse : \"preauth_response\",\n\n    PreauthTopupRequest: \"preauth_topup\",\n    PreauthTopupResponse: \"preauth_topup_response\",\n\n    PreauthExtendRequest: \"preauth_extend\",\n    PreauthExtendResponse: \"preauth_extend_response\",\n\n    PreauthPartialCancellationRequest : \"preauth_partial_cancellation\",\n    PreauthPartialCancellationResponse : \"preauth_partial_cancellation_response\",\n    \n    PreauthCancellationRequest : \"preauth_cancellation\",\n    PreauthCancellationResponse : \"preauth_cancellation_response\",\n\n    PreauthCompleteRequest : \"completion\",\n    PreauthCompleteResponse : \"completion_response\"\n};\n\nexport class AccountVerifyRequest\n{\n    constructor(posRefId)\n    {\n        this.PosRefId = posRefId;\n    }\n\n    ToMessage()\n    {\n        var data = {\n            \"pos_ref_id\": this.PosRefId\n        };\n\n        return new Message(RequestIdHelper.Id(\"prav\"), PreauthEvents.AccountVerifyRequest, data, true);\n    }\n}\n\nexport class AccountVerifyResponse\n{\n    constructor(m)\n    {\n        this.Details = new PurchaseResponse(m);\n        this.PosRefId = this.Details.PosRefId;\n        this._m = m;\n    }\n}\n\nexport class PreauthOpenRequest\n{\n    constructor(amountCents, posRefId)\n    {\n        this.PosRefId = posRefId;\n        this.PreauthAmount = amountCents;\n    }\n\n    ToMessage()\n    {\n        var data = {\n            \"pos_ref_id\": this.PosRefId,\n            \"preauth_amount\": this.PreauthAmount\n        };\n\n        return new Message(RequestIdHelper.Id(\"prac\"), PreauthEvents.PreauthOpenRequest, data, true);\n    }\n}\n\nexport class PreauthTopupRequest\n{\n    constructor(preauthId, topupAmountCents, posRefId)\n    {\n        this.PreauthId = preauthId;\n        this.TopupAmount = topupAmountCents;\n        this.PosRefId = posRefId;\n    }\n\n    ToMessage()\n    {\n        var data = {\n            \"pos_ref_id\": this.PosRefId,\n            \"preauth_id\": this.PreauthId,\n            \"topup_amount\": this.TopupAmount\n        };\n\n        return new Message(RequestIdHelper.Id(\"prtu\"), PreauthEvents.PreauthTopupRequest, data, true);\n    }\n}\n\nexport class PreauthPartialCancellationRequest\n{\n    constructor(preauthId, partialCancellationAmountCents, posRefId)\n    {\n        this.PreauthId = preauthId;\n        this.PartialCancellationAmount = partialCancellationAmountCents;\n        this.PosRefId = posRefId;\n    }\n\n    ToMessage()\n    {\n        var data = {\n            \"pos_ref_id\": this.PosRefId,\n            \"preauth_id\": this.PreauthId,\n            \"preauth_cancel_amount\": this.PartialCancellationAmount\n        };\n\n        return new Message(RequestIdHelper.Id(\"prpc\"), PreauthEvents.PreauthPartialCancellationRequest, data, true);\n    }\n}\n\nexport class PreauthExtendRequest\n{\n    constructor(preauthId, posRefId)\n    {\n        this.PreauthId = preauthId;\n        this.PosRefId = posRefId;\n    }\n\n    ToMessage()\n    {\n        var data = {\n            \"pos_ref_id\": this.PosRefId,\n            \"preauth_id\": this.PreauthId\n        };\n\n        return new Message(RequestIdHelper.Id(\"prext\"), PreauthEvents.PreauthExtendRequest, data, true);\n    }\n}\n\nexport class PreauthCancelRequest\n{\n    constructor(preauthId, posRefId)\n    {\n        this.PreauthId = preauthId;\n        this.PosRefId = posRefId;\n    }\n\n    ToMessage()\n    {\n        var data = {\n            \"pos_ref_id\": this.PosRefId,\n            \"preauth_id\": this.PreauthId\n        };\n\n        return new Message(RequestIdHelper.Id(\"prac\"), PreauthEvents.PreauthCancellationRequest, data, true);\n    }\n}\n\nexport class PreauthCompletionRequest\n{\n    constructor(preauthId, completionAmountCents, posRefId, surchargeAmount)\n    {\n        this.PreauthId = preauthId;\n        this.CompletionAmount = completionAmountCents;\n        this.PosRefId = posRefId;\n        this.SurchargeAmount = surchargeAmount;\n    }\n\n    ToMessage()\n    {\n        var data = {\n            \"pos_ref_id\": this.PosRefId,\n            \"preauth_id\": this.PreauthId,\n            \"completion_amount\": this.CompletionAmount,\n            \"surcharge_amount\": this.SurchargeAmount\n        };\n\n        return new Message(RequestIdHelper.Id(\"prac\"), PreauthEvents.PreauthCompleteRequest, data, true);\n    }\n}\n\nexport class PreauthResponse\n{\n    constructor(m)\n    {\n        this.PreauthId = m.Data[\"preauth_id\"];\n        this.Details = new PurchaseResponse(m);\n        this.PosRefId = this.Details.PosRefId;\n        this._m = m;\n    }\n\n    GetBalanceAmount()\n    {\n        var txType = this._m.Data[\"transaction_type\"];\n        switch (txType)\n        {\n            case \"PRE-AUTH\":\n                return this._m.Data[\"preauth_amount\"];\n            case \"TOPUP\":\n                return this._m.Data[\"balance_amount\"];\n            case \"CANCEL\": // PARTIAL CANCELLATION\n                return this._m.Data[\"balance_amount\"];\n            case \"PRE-AUTH EXT\":\n                return this._m.Data[\"balance_amount\"];\n            case \"PCOMP\":\n                return 0; // Balance is 0 after completion\n            case \"PRE-AUTH CANCEL\":\n                return 0; // Balance is 0 after cancellation\n            default:\n                return 0;\n        }\n    }\n\n    GetPreviousBalanceAmount()\n    {\n        var txType = this._m.Data[\"transaction_type\"];\n        switch (txType)\n        {   \n            case \"PRE-AUTH\":\n                return 0;\n            case \"TOPUP\":\n                return this._m.Data[\"existing_preauth_amount\"];\n            case \"CANCEL\": // PARTIAL CANCELLATION\n                return this._m.Data[\"existing_preauth_amount\"];\n            case \"PRE-AUTH EXT\":\n                return this._m.Data[\"existing_preauth_amount\"];\n            case \"PCOMP\":\n                // THIS IS TECHNICALLY NOT CORRECT WHEN COMPLETION HAPPENS FOR A PARTIAL AMOUNT.\n                // BUT UNFORTUNATELY, THIS RESPONSE DOES NOT CONTAIN \"existing_preauth_amount\".\n                // SO \"completion_amount\" IS THE CLOSEST WE HAVE.\n                return this._m.Data[\"completion_amount\"];\n            case \"PRE-AUTH CANCEL\":\n                return this._m.Data[\"preauth_amount\"];\n            default:\n                return 0;\n        }\n    }\n    \n    GetCompletionAmount()\n    {\n        var txType = this._m.Data[\"transaction_type\"];\n        switch (txType)\n        {   \n            case \"PCOMP\":\n                return this._m.Data[\"completion_amount\"];\n            default:\n                return 0;\n        }\n\n    }\n\n    GetSurchargeAmount()\n    {\n        var txType = this._m.Data[\"transaction_type\"];\n        switch (txType)\n        {\n            case \"PCOMP\":\n                return this._m.Data[\"surcharge_amount\"];\n            default:\n                return 0;\n        }\n    }\n}","import {\n    PreauthEvents,\n    AccountVerifyRequest, \n    PreauthOpenRequest, \n    PreauthTopupRequest, \n    PreauthPartialCancellationRequest, \n    PreauthExtendRequest,\n    PreauthCompletionRequest,\n    PreauthCancelRequest} from './Preauth';\n\nimport {TransactionFlowState, InitiateTxResult} from './SpiModels';\n\nexport class SpiPreauth\n{\n    constructor(spi)\n    {\n        this._spi = spi;\n        this._log = console;\n    }\n\n    InitiateAccountVerifyTx(posRefId)\n    {\n        var verifyMsg = new AccountVerifyRequest(posRefId).ToMessage();\n        var tfs = new TransactionFlowState(\n            posRefId, TransactionType.AccountVerify, 0, verifyMsg,\n            \"Waiting for EFTPOS connection to make account verify request\");\n        var sentMsg = \"Asked EFTPOS to verify account\";\n        return this._initiatePreauthTx(tfs, sentMsg);\n    }\n    \n    InitiateOpenTx(posRefId, amountCents)\n    {\n        var msg = new PreauthOpenRequest(amountCents, posRefId).ToMessage();\n        var tfs = new TransactionFlowState(\n            posRefId, TransactionType.Preauth, amountCents, msg,\n            `Waiting for EFTPOS connection to make preauth request for ${(amountCents / 100.0).toFixed(2)}`);\n        var sentMsg = `Asked EFTPOS to create preauth for ${(amountCents / 100.0).toFixed(2)}`;\n        return this._initiatePreauthTx(tfs, sentMsg);\n    }\n\n    InitiateTopupTx(posRefId, preauthId, amountCents)\n    {\n        var msg = new PreauthTopupRequest(preauthId, amountCents, posRefId).ToMessage();\n        var tfs = new TransactionFlowState(\n            posRefId, TransactionType.Preauth, amountCents, msg,\n            `Waiting for EFTPOS connection to make preauth topup request for ${(amountCents / 100.0).toFixed(2)}`);\n        var sentMsg = `Asked EFTPOS to make preauth topup for ${(amountCents / 100.0).toFixed(2)}`;\n        return this._initiatePreauthTx(tfs, sentMsg);\n    }\n\n    InitiatePartialCancellationTx(posRefId, preauthId, amountCents)\n    {\n        var msg = new PreauthPartialCancellationRequest(preauthId, amountCents, posRefId).ToMessage();\n        var tfs = new TransactionFlowState(\n            posRefId, TransactionType.Preauth, amountCents, msg,\n            `Waiting for EFTPOS connection to make preauth partial cancellation request for ${(amountCents / 100.0).toFixed(2)}`);\n        var sentMsg = `Asked EFTPOS to make preauth partial cancellation for ${(amountCents / 100.0).toFixed(2)}`;\n        return this._initiatePreauthTx(tfs, sentMsg);\n    }\n\n    InitiateExtendTx(posRefId, preauthId)\n    {\n        var msg = new PreauthExtendRequest(preauthId, posRefId).ToMessage();\n        var tfs = new TransactionFlowState(\n            posRefId, TransactionType.Preauth, 0, msg,\n            \"Waiting for EFTPOS connection to make preauth Extend request\");\n        var sentMsg = \"Asked EFTPOS to make preauth Extend request\";\n        return this._initiatePreauthTx(tfs, sentMsg);\n    }\n\n    InitiateCompletionTx(posRefId, preauthId, amountCents, surchargeAmount)\n    {\n        var msg = new PreauthCompletionRequest(preauthId, amountCents, posRefId, surchargeAmount).ToMessage();\n        var tfs = new TransactionFlowState(\n            posRefId, TransactionType.Preauth, amountCents, msg,\n            `Waiting for EFTPOS connection to make preauth completion request for ${(amountCents / 100.0).toFixed(2)}`);\n        var sentMsg = `Asked EFTPOS to make preauth completion for ${(amountCents / 100.0).toFixed(2)}`;\n        return this._initiatePreauthTx(tfs, sentMsg);\n    }\n\n    InitiateCancelTx(posRefId, preauthId)\n    {\n        var msg = new PreauthCancelRequest(preauthId, posRefId).ToMessage();\n        var tfs = new TransactionFlowState(\n            posRefId, TransactionType.Preauth, 0, msg,\n            \"Waiting for EFTPOS connection to make preauth cancellation request\");\n        var sentMsg = \"Asked EFTPOS to make preauth cancellation request\";\n        return this._initiatePreauthTx(tfs, sentMsg);\n    }\n\n    _initiatePreauthTx(tfs, sentMsg)\n    {\n        if (this._spi.CurrentStatus == SpiStatus.Unpaired) return new InitiateTxResult(false, \"Not Paired\");\n\n        if (this._spi.CurrentFlow != SpiFlow.Idle) return new InitiateTxResult(false, \"Not Idle\");\n\n        this._spi.CurrentFlow = SpiFlow.Transaction;\n        this._spi.CurrentTxFlowState = tfs;\n        if (this._spi._send(tfs.Request))\n        {\n            this._spi.CurrentTxFlowState.Sent(sentMsg);\n        }\n    \n        document.dispatchEvent(new CustomEvent('TxFlowStateChanged', {detail: this._spi.CurrentTxFlowState}));\n        return new InitiateTxResult(true, \"Preauth Initiated\");\n    }\n\n    _handlePreauthMessage(m)\n    {\n        switch (m.EventName)\n        {\n            case PreauthEvents.AccountVerifyResponse:\n                this._handleAccountVerifyResponse(m);\n                break;\n            case PreauthEvents.PreauthOpenResponse:\n            case PreauthEvents.PreauthTopupResponse:\n            case PreauthEvents.PreauthPartialCancellationResponse:\n            case PreauthEvents.PreauthExtendResponse:\n            case PreauthEvents.PreauthCompleteResponse:\n            case PreauthEvents.PreauthCancellationResponse:\n                this._handlePreauthResponse(m);\n                break;\n            default:\n                this._log.info(`I don't Understand Preauth Event: ${m.EventName}, ${m.Data}. Perhaps I have not implemented it yet.`);\n                break;\n        }\n    }\n\n    _handleAccountVerifyResponse(m)\n    {\n        var incomingPosRefId = m.Data.pos_ref_id;\n        var currentTxFlowState = this._spi.CurrentTxFlowState;\n        if (this._spi.CurrentFlow != SpiFlow.Transaction || currentTxFlowState.Finished || !currentTxFlowState.PosRefId === incomingPosRefId)\n        {\n            this._log.info(`Received Account Verify response but I was not waiting for one. Incoming Pos Ref ID: ${incomingPosRefId}`);\n            return;\n        }\n        // TH-1A, TH-2A\n\n        currentTxFlowState.Completed(m.GetSuccessState(), m, \"Account Verify Transaction Ended.\");\n        // TH-6A, TH-6E\n        \n        document.dispatchEvent(new CustomEvent('TxFlowStateChanged', {detail: this._spi.CurrentTxFlowState}));\n    }\n    \n    _handlePreauthResponse(m)\n    {\n        var incomingPosRefId = m.Data.pos_ref_id;\n        var currentTxFlowState = this._spi.CurrentTxFlowState;\n        if (this._spi.CurrentFlow != SpiFlow.Transaction || currentTxFlowState.Finished || !currentTxFlowState.PosRefId === incomingPosRefId)\n        {\n            this._log.info(`Received Preauth response but I was not waiting for one. Incoming Pos Ref ID: ${incomingPosRefId}`);\n            return;\n        }\n        // TH-1A, TH-2A\n\n        currentTxFlowState.Completed(m.GetSuccessState(), m, \"Preauth Transaction Ended.\");\n        // TH-6A, TH-6E\n        \n        document.dispatchEvent(new CustomEvent('TxFlowStateChanged', {detail: this._spi.CurrentTxFlowState}));\n    }\n\n    static IsPreauthEvent(eventName)\n    {\n        return eventName.lastIndexOf(\"preauth\",0) === 0 \n                || eventName == PreauthEvents.PreauthCompleteResponse\n                || eventName == PreauthEvents.PreauthCompleteRequest\n                || eventName == PreauthEvents.AccountVerifyRequest\n                || eventName == PreauthEvents.AccountVerifyResponse;\n    }\n}\n","import {Events} from './Messages';\nimport {RequestIdHelper} from './RequestIdHelper';\n\n// <summary>\n// Pairing Interaction 1: Outgoing\n// </summary>\nexport class PairRequest {\n    ToMessage() {\n        let data = {padding: true};\n        return new Message(RequestIdHelper.Id(\"pr\"), Events.PairRequest, data, false);\n    }\n}\n\n// Pairing Interaction 2: Incoming\nexport class KeyRequest {\n    constructor(m) {\n        this.RequestId = m.Id;\n        this.Aenc = m.Data.enc.A;\n        this.Ahmac = m.Data.hmac.A;\n    }\n}\n\n// Pairing Interaction 3: Outgoing\nexport class KeyResponse {\n    constructor(requestId, Benc, Bhmac) {\n        this.RequestId = requestId;\n        this.Benc = Benc;\n        this.Bhmac = Bhmac;\n    }\n\n    ToMessage() {\n        let data = {\n            enc: {\n                B: this.Benc\n            },\n            hmac: {\n                B: this.Bhmac\n            }\n        };\n\n        return new Message(this.RequestId, Events.KeyResponse, data, false);\n    }\n}\n\n// Pairing Interaction 4: Incoming\nexport class KeyCheck {\n    constructor(m) {\n        this.ConfirmationCode = m.IncomingHmac.substring(0,6);\n    }\n}\n\n// Pairing Interaction 5: Incoming\nexport class PairResponse {\n    constructor(m) {\n        this.Success = m.Data.success;\n    }\n}\n\n// Holder class for Secrets and KeyResponse, so that we can use them together in method signatures.\nexport class SecretsAndKeyResponse {\n    constructor(secrets, keyResponse) {\n        this.Secrets = secrets;\n        this.KeyResponse = keyResponse;\n    }\n}\n\nexport class DropKeysRequest\n{\n    ToMessage()\n    {\n        return new Message(RequestIdHelper.Id(\"drpkys\"), Events.DropKeysAdvice, null, true);\n    }\n}","import {Events, SuccessState} from './Messages';\n\nexport class SetPosInfoRequest\n{\n    constructor(version, vendorId, libraryLanguage, libraryVersion, otherInfo)\n    {\n        this._version = version;\n        this._vendorId = vendorId;\n        this._libraryLanguage = libraryLanguage;\n        this._libraryVersion = libraryVersion;\n        this._otherInfo = otherInfo;\n    }\n\n    toMessage()\n    {\n        var data = {\n            pos_version: this._version,\n            pos_vendor_id: this._vendorId,\n            library_language: this._libraryLanguage,\n            library_version: this._libraryVersion,\n            other_info: this._otherInfo\n        };\n\n        return new Message(RequestIdHelper.Id(\"prav\"), Events.SetPosInfoRequest, data, true);\n    }\n}\n\nexport class SetPosInfoResponse\n{\n    constructor(m)\n    {\n        this._success = m.GetSuccessState() == SuccessState.Success;\n        this._m = m;\n    }\n    isSuccess()\n    {\n        return this._success;\n    }\n    getErrorReason()\n    {\n        return this._m.Data.error_reason;\n    }\n    getErrorDetail()\n    {\n        return this._m.Data.error_detail;\n    }\n    getResponseValueWithAttribute(attribute)\n    {\n        return this._m.Data[attribute];\n    }\n}\n\nexport class DeviceInfo\n{\n    static GetAppDeviceInfo()\n    {\n        var deviceInfo = {};\n        deviceInfo['device_system'] = navigator.userAgent;\n        // deviceInfo.Add(\"device_system\", Environment.OSVersion.Platform.ToString() + \" \" + Environment.OSVersion.Version.ToString());\n        return deviceInfo;\n    }\n}\n","import {Events, SuccessState} from './Messages';\nimport {RequestIdHelper} from './RequestIdHelper';\n\nexport class PurchaseRequest {\n    constructor(amountCents, posRefId) {\n        this.PosRefId = posRefId;\n        this.PurchaseAmount = amountCents;\n        this.TipAmount = 0;\n        this.CashoutAmount = 0;\n        this.PromptForCashout = false;\n        this.SurchargeAmount = 0;\n        this.Config = new SpiConfig();\n        this.Options = new TransactionOptions();\n\n        // Library Backwards Compatibility\n        this.Id = posRefId;\n        this.AmountCents = amountCents;\n    }\n\n    AmountSummary()\n    {\n        return `Purchase: ${(this.PurchaseAmount / 100.0).toFixed(2)}; \n            Tip: ${(this.TipAmount / 100.0).toFixed(2)}; \n            Cashout: ${(this.CashoutAmount / 100.0).toFixed(2)};`;\n    }\n\n    ToMessage() {\n        let data = {\n            pos_ref_id: this.PosRefId,\n            purchase_amount: this.PurchaseAmount,\n            tip_amount: this.TipAmount,\n            cash_amount: this.CashoutAmount,\n            prompt_for_cashout: this.PromptForCashout, \n            surcharge_amount: this.SurchargeAmount\n        };\n\n        this.Config.addReceiptConfig(data);\n        this.Options.AddOptions(data);\n        return new Message(RequestIdHelper.Id(\"prchs\"), Events.PurchaseRequest, data, true);\n    }\n}\n\nexport class PurchaseResponse\n{\n    constructor(m)\n    {\n        this._m = m;\n        this.RequestId = m.Id;\n        this.PosRefId = m.Data.pos_ref_id;\n        this.SchemeName = m.Data.scheme_name;\n        this.SchemeAppName = m.Data.scheme_name;\n        this.Success = m.GetSuccessState() == SuccessState.Success;\n    }\n\n    GetRRN()\n    {\n        return this._m.Data.rrn;\n    }\n\n    GetPurchaseAmount()\n    {\n        return this._m.Data.purchase_amount;\n    }\n\n    GetTipAmount()\n    {\n        return this._m.Data.tip_amount;\n    }\n\n    GetSurchargeAmount()\n    {\n        return this._m.Data.surcharge_amount;\n    }\n\n    GetCashoutAmount()\n    {\n        return this._m.Data.cash_amount;\n    }\n\n    GetBankNonCashAmount()\n    {\n        return this._m.Data.bank_noncash_amount;\n    }\n\n    GetBankCashAmount()\n    {\n        return this._m.Data.bank_cash_amount;\n    }\n\n    GetCustomerReceipt()\n    {\n        return this._m.Data.customer_receipt || \"\";\n    }\n\n    GetMerchantReceipt()\n    {\n        return this._m.Data.merchant_receipt || \"\";\n    }\n\n    GetResponseText()\n    {\n        return this._m.Data.host_response_text || \"\";\n    }\n\n    GetResponseCode()\n    {\n        return this._m.Data.host_response_code;\n    }\n    \n    GetTerminalReferenceId()\n    {\n        return this._m.Data.terminal_ref_id;\n    }\n\n    GetCardEntry()\n    {\n        return this._m.Data.card_entry;\n    }\n    \n    GetAccountType()\n    {\n        return this._m.Data.account_type;\n    }\n\n    GetAuthCode()\n    {\n        return this._m.Data.auth_code;\n    }\n\n    GetBankDate()\n    {\n        return this._m.Data.bank_date;\n    }\n\n    GetBankTime()\n    {\n        return this._m.Data.bank_time;\n    }\n    \n    GetMaskedPan()\n    {\n        return this._m.Data.masked_pan;\n    }\n    \n    GetTerminalId()\n    {\n        return this._m.Data.terminal_id;\n    }\n\n    WasMerchantReceiptPrinted()\n    {\n        return this._m.Data.merchant_receipt_printed;\n    }\n\n    WasCustomerReceiptPrinted()\n    {\n        return this._m.Data.customer_receipt_printed;\n    }\n    \n    GetSettlementDate()\n    {\n        //\"bank_settlement_date\":\"20042018\"\n        var dateStr = this._m.Data.bank_settlement_date;\n        if (!dateStr) return null;\n        return Message.ParseBankDate(dateStr);\n    }\n\n    GetResponseValue(attribute)\n    {\n        return this._m.Data[attribute];\n    }\n\n    ToPaymentSummary()\n    {\n        return {\n            account_type: this.GetAccountType(),\n            auth_code: this.GetAuthCode(),\n            bank_date: this.GetBankDate(),\n            bank_time: this.GetBankTime(),\n            host_response_code: this.GetResponseCode(),\n            host_response_text: this.GetResponseText(),\n            masked_pan: this.GetMaskedPan(),\n            purchase_amount: this.GetPurchaseAmount(),\n            rrn: this.GetRRN(),\n            scheme_name: this.SchemeName,\n            terminal_id: this.GetTerminalId(),\n            terminal_ref_id: this.GetTerminalReferenceId(),\n            tip_amount: this.GetTipAmount(),\n            surcharge_amount: this.GetSurchargeAmount()\n        };\n    }\n}\n\nexport class CancelTransactionRequest\n{\n    \n    ToMessage()\n    {\n        return new Message(RequestIdHelper.Id(\"ctx\"), Events.CancelTransactionRequest, null, true);\n    }\n}\n\nexport class CancelTransactionResponse\n{\n    constructor(m)\n    {\n        this._m = m;\n        this.PosRefId = this._m.Data.pos_ref_id;\n        this.Success = this._m.GetSuccessState() == SuccessState.Success;\n    }\n\n    GetErrorReason()\n    {\n        return this._m.Data.error_reason;\n    }\n\n    GetErrorDetail()\n    {\n        return this._m.Data.error_detail;\n    }\n\n    GetResponseValueWithAttribute(attribute)\n    {\n        return this._m.Data[attribute];\n    }\n}\n\nexport class GetLastTransactionRequest\n{\n    ToMessage()\n    {\n        return new Message(RequestIdHelper.Id(\"glt\"), Events.GetLastTransactionRequest, null, true);\n    }\n}\n\nexport class GetLastTransactionResponse\n{\n    constructor(m)\n    {\n        this._m = m;\n    }\n\n    WasRetrievedSuccessfully()\n    {\n        // We can't rely on checking \"success\" flag or \"error\" fields here,\n        // as retrieval may be successful, but the retrieved transaction was a fail.\n        // So we check if we got back an ResponseCode.\n        // (as opposed to say an operation_in_progress_error)\n        return !!this.GetResponseCode();\n    }\n\n    WasTimeOutOfSyncError()\n    {\n        return this._m.GetError().startsWith(\"TIME_OUT_OF_SYNC\");\n    }\n\n    WasOperationInProgressError()\n    {\n        return this._m.GetError().startsWith(\"OPERATION_IN_PROGRESS\");\n    }\n\n    IsWaitingForSignatureResponse()\n    {\n        return this._m.GetError().startsWith(\"OPERATION_IN_PROGRESS_AWAITING_SIGNATURE\");\n    }\n\n    IsWaitingForAuthCode()\n    {\n        return this._m.GetError().startsWith(\"OPERATION_IN_PROGRESS_AWAITING_PHONE_AUTH_CODE\");\n    }\n    \n    IsStillInProgress(posRefId)\n    {\n        return this.WasOperationInProgressError() && this.GetPosRefId() == posRefId;\n    }\n\n    GetSuccessState()\n    {\n        return this._m.GetSuccessState();\n    }\n\n    WasSuccessfulTx()\n    {\n        return this._m.GetSuccessState() == SuccessState.Success;\n    }\n\n    GetTxType()\n    {\n        return this._m.Data.transaction_type;\n    }\n\n    GetPosRefId()\n    {\n        return this._m.Data.pos_ref_id;\n    }\n\n    GetSchemeApp()\n    {\n        return this._m.Data.scheme_name;\n    }\n\n    GetSchemeName()\n    {\n        return this._m.Data.scheme_name;\n    }\n\n    GetAmount()\n    {\n        return this._m.Data.amount_purchase;\n    }\n\n    GetTransactionAmount()\n    {\n        return this._m.Data.amount_transaction_type;\n    }\n\n    GetBankDateTimeString()\n    {\n        var ds = this._m.Data.bank_date + this._m.Data.bank_time;\n        return ds;\n    }\n\n    GetRRN()\n    {\n        return this._m.Data.rrn;\n    }\n    \n    GetResponseText()\n    {\n        return this._m.Data.host_response_text | \"\";\n    }\n\n    GetResponseCode()\n    {\n        return this._m.Data.host_response_code;\n    }\n\n    // <summary>\n    // There is a bug, VSV-920, whereby the customer_receipt is missing from a glt response.\n    // The current recommendation is to use the merchant receipt in place of it if required.\n    // This method modifies the underlying incoming message data by copying\n    // the merchant receipt into the customer receipt only if there \n    // is a merchant_receipt and there is not a customer_receipt.   \n    // </summary>\n    CopyMerchantReceiptToCustomerReceipt()\n    {\n        var cr = this._m.Data.customer_receipt;\n        var mr = this._m.Data.merchant_receipt;\n        if (mr != \"\" && !(cr))\n        {\n            this._m.Data.customer_receipt = mr;\n        }\n    }\n}\n\nexport class RefundRequest\n{\n    constructor(amountCents, posRefId)\n    {\n        this.AmountCents = amountCents;\n        this.Id = RequestIdHelper.Id(\"refund\");\n        this.PosRefId = posRefId;\n        this.Config = new SpiConfig();\n        this.Options = new TransactionOptions();\n    }\n    \n    ToMessage()\n    {\n        let data = {refund_amount: this.AmountCents, pos_ref_id: this.PosRefId};\n        this.Config.addReceiptConfig(data);\n        this.Options.AddOptions(data);\n        return new Message(RequestIdHelper.Id(\"refund\"), Events.RefundRequest, data, true);\n    }\n}\n\nexport class RefundResponse\n{\n    constructor(m)\n    {\n        this._m = m;\n        this.RequestId = m.Id;\n        this.PosRefId = m.Data.pos_ref_id;\n        this.SchemeName = m.Data.scheme_name;\n        this.SchemeAppName = m.Data.scheme_name;\n        this.Success = m.GetSuccessState() == SuccessState.Success;\n    }\n\n    GetRefundAmount()\n    {\n        return this._m.Data.refund_amount;\n    }\n\n    GetRRN()\n    {\n        return this._m.Data.rrn;\n    }\n\n    GetCustomerReceipt()\n    {\n        return this._m.Data.customer_receipt || \"\";\n    }\n\n    GetMerchantReceipt()\n    {\n        return this._m.Data.merchant_receipt;\n    }\n    \n    GetResponseText()\n    {\n        return this._m.Data.host_response_text || \"\";\n    }\n\n    GetResponseCode()\n    {\n        return this._m.Data.host_response_code || \"\";\n    }\n\n\n    GetTerminalReferenceId()\n    {\n        return this._m.Data.terminal_ref_id || \"\";\n    }\n    GetCardEntry()\n    {\n        return this._m.Data.card_entry || \"\";\n    }\n    GetAccountType()\n    {\n        return this._m.Data.account_type || \"\";\n    }\n    GetAuthCode()\n    {\n        return this._m.Data.auth_code || \"\";\n    }\n    GetBankDate()\n    {\n        return this._m.Data.bank_date || \"\";\n    }\n    GetBankTime()\n    {\n        return this._m.Data.bank_time || \"\";\n    }\n    GetMaskedPan()\n    {\n        return this._m.Data.masked_pan || \"\";\n    }\n    GetTerminalId()\n    {\n        return this._m.Data.terminal_id || \"\";\n    }\n    WasMerchantReceiptPrinted()\n    {\n        return this._m.Data.merchant_receipt_printed;\n    }\n    WasCustomerReceiptPrinted()\n    {\n        return this._m.Data.customer_receipt_printed;\n    }\n    GetSettlementDate()\n    {\n        //\"bank_settlement_date\":\"20042018\"\n        var dateStr = this._m.Data.bank_settlement_date;\n        if (!dateStr) return null;\n        return Message.ParseBankDate(dateStr);\n    }\n\n    GetResponseValue(attribute)\n    {\n        return this._m.Data[attribute];\n    }\n}\n\nexport class SignatureRequired\n{\n    constructor(m)\n    {\n        this.RequestId = m.Id;\n        this.PosRefId = m.Data.pos_ref_id;\n        this._receiptToSign = m.Data.merchant_receipt;\n    }\n    \n    SignatureRequired(posRefId, requestId, receiptToSign)\n    {\n        this.RequestId = requestId;\n        this.PosRefId = posRefId;\n        this._receiptToSign = receiptToSign;\n    }\n\n    GetMerchantReceipt()\n    {\n        return this._receiptToSign;\n    }\n}\n\nexport class SignatureDecline\n{\n    constructor(posRefId)\n    {\n        this.PosRefId = posRefId;\n    }\n\n    ToMessage()\n    {\n        var data = {\n            pos_ref_id: this.PosRefId\n        };\n        return new Message(RequestIdHelper.Id(\"sigdec\"), Events.SignatureDeclined, data, true);\n    }\n}\n\nexport class SignatureAccept\n{\n    constructor(posRefId)\n    {\n        this.PosRefId = posRefId;\n    }\n\n    ToMessage()\n    {\n        var data = {\n            pos_ref_id: this.PosRefId\n        };\n        return new Message(RequestIdHelper.Id(\"sigacc\"), Events.SignatureAccepted, data, true);\n    }\n}\n\nexport class MotoPurchaseRequest\n{\n    constructor(amountCents, posRefId, surchargeAmount)\n    {\n        this.PosRefId = posRefId;\n        this.PurchaseAmount = amountCents;\n        this.SurchargeAmount = surchargeAmount;\n        this.Config = new SpiConfig();\n        this.Options = new TransactionOptions();\n    }\n\n    ToMessage()\n    {\n        var data = {\n            pos_ref_id: this.PosRefId,\n            purchase_amount: this.PurchaseAmount,\n            surcharge_amount: this.SurchargeAmount\n        };\n        this.Config.addReceiptConfig(data);\n        this.Options.AddOptions(data);\n        return new Message(RequestIdHelper.Id(\"moto\"), Events.MotoPurchaseRequest, data, true);\n    }\n}\n\nexport class MotoPurchaseResponse\n{\n    constructor(m)\n    {\n        this.PurchaseResponse = new PurchaseResponse(m);\n        this.PosRefId = PurchaseResponse.PosRefId;\n    }\n}\n\nexport class PhoneForAuthRequired\n{\n    constructor(...args)\n    {\n        if(args.length === 4) {\n            this.PosRefId = args[0];\n            this.RequestId = args[1];\n            this._phoneNumber = args[2];\n            this._merchantId = args[3];\n        } else if(args.length === 1) {\n            this.RequestId = args[0].Id;\n            this.PosRefId = args[0].Data.pos_ref_id;\n            this._phoneNumber = args[0].Data.auth_centre_phone_number;\n            this._merchantId = args[0].Data.merchant_id;\n        } else {\n            throw new Error('Invalid call sig for Phone auth required class');\n        }\n    }\n    \n    GetPhoneNumber()\n    {\n        return this._phoneNumber;\n    }\n    \n    GetMerchantId()\n    {\n        return this._merchantId;\n    }\n}\n\nexport class AuthCodeAdvice\n{\n    constructor(posRefId, authCode)\n    {\n        this.PosRefId = posRefId;\n        this.AuthCode = authCode;\n    }\n\n    ToMessage()\n    {\n        var data = {\n            pos_ref_id: this.PosRefId,\n            auth_code: this.AuthCode\n        };\n        return new Message(RequestIdHelper.Id(\"authad\"), Events.AuthCodeAdvice, data, true);\n    }\n}","class DeviceIpAddressStatus\n{\n    constructor(ip, last_updated) \n    {\n        this.Ip = ip;\n        this.Last_updated = last_updated;\n    }\n}\n\nclass DeviceIpAddressService\n{\n    RetrieveService(serialNumber, apiKey = 'spi-sample-pos1')\n    {\n        var deviceIpUrl =\n            `https://device-address-api-dev.nonprod-wbc.msp.assemblypayments.com/v1/${serialNumber}/ip`;\n\n        return fetch(deviceIpUrl, {\n            method: 'GET',\n            headers: {\n                \"ASM-MSP-DEVICE-ADDRESS-API-KEY\": apiKey\n            }\n        })\n        .then(response => response.json())\n        .catch((response) => {\n            console.error(`Status code ${response.StatusCode} received from ${deviceIpUrl} - Exception ${response.ErrorException}`);\n        })\n    }\n}\n\nexport {DeviceIpAddressStatus, DeviceIpAddressService};","import {Message, MessageStamp, Events, SuccessState} from './Messages';\nimport {SpiConfig, SpiFlow, SpiStatus, PairingFlowState, TransactionFlowState, InitiateTxResult} from './SpiModels';\nimport {RequestIdHelper} from './RequestIdHelper';\nimport {SpiPayAtTable} from './SpiPayAtTable';\nimport {SpiPreauth} from './SpiPreauth';\nimport {DropKeysRequest} from './Pairing';\nimport {SetPosInfoRequest} from './PosInfo';\nimport {GetLastTransactionRequest, CancelTransactionRequest, SignatureRequired, CancelTransactionResponse} from './Purchase';\nimport {DeviceIpAddressService, DeviceIpAddressStatus} from './Service/DeviceService';\n\nconst SPI_VERSION = '2.4.5';\n\nexport default class Spi {\n\n    get CurrentStatus() {\n        return this._currentStatus;\n    }\n\n    set CurrentStatus(value) {\n        if(this._currentStatus === value) {\n            return;\n        }\n\n        this._currentStatus = value;\n        document.dispatchEvent(new CustomEvent('StatusChanged', {detail: value}));\n    }\n\n    constructor(posId, eftposAddress, secrets, deviceIpAddressRequest) \n    {\n        this._posId = posId;\n        this._secrets = secrets;\n        this._eftposAddress = \"ws://\" + eftposAddress;\n        this._log = console;\n        this.Config = new SpiConfig();\n\n        if (deviceIpAddressRequest)\n        {\n            this._serialNumber = deviceIpAddressRequest.SerialNumber;\n            this._deviceApiKey = deviceIpAddressRequest.ApiKey;\n        }\n\n        this.CurrentDeviceStatus = null;\n        this.AutoIpResolutionEnable = false;\n\n        // Our stamp for signing outgoing messages\n        this._spiMessageStamp = new MessageStamp(this._posId, this._secrets, 0);\n\n        this._posVendorId = null;\n        this._posVersion = null;\n        this._hasSetInfo = null;\n\n        // We will maintain some state\n        this._mostRecentPingSent = null;\n        this._mostRecentPongReceived = null;\n        this._missedPongsCount = 0;\n        this._retrySinceLastDeviceIpAddressResolution = 0;\n        this._mostRecentLoginResponse = null;\n\n        this._pongTimeout = 5000;\n        this._pingFrequency = 18000;\n        \n        this._readyToTransact = null;\n        this._periodicPingThread = null;\n\n        this._txMonitorCheckFrequency = 1000;\n        this._checkOnTxFrequency = 20000;\n        this._maxWaitForCancelTx = 10000;\n        this._missedPongsToDisconnect = 2;\n        this._retryBeforeResolvingDeviceIpAddress = 5;\n\n        this.CurrentFlow                = null;\n        this.CurrentPairingFlowState    = null;\n        this.CurrentTxFlowState         = null;\n    }\n\n    EnablePayAtTable()\n    {\n        this._spiPat = new SpiPayAtTable(this);\n        return this._spiPat;\n    }\n\n    EnablePreauth()\n    {\n        this._spiPreauth = new SpiPreauth(this);\n        return this._spiPreauth;\n    }\n\n    Start() {\n\n        if (!this._posVendorId || !this._posVersion)\n        {\n            // POS information is now required to be set\n            this._log.Warn(\"Missing POS vendor ID and version. posVendorId and posVersion are required before starting\");\n            throw new Exception(\"Missing POS vendor ID and version. posVendorId and posVersion are required before starting\");\n        }\n\n        this._resetConn();\n        this._startTransactionMonitoringThread();\n\n        this.CurrentFlow = SpiFlow.Idle;\n        if (this._secrets != null)\n        {\n            this._log.info(\"Starting in Paired State\");\n            this._currentStatus = SpiStatus.PairedConnecting;\n            this._conn.Connect(); // This is non-blocking\n        }\n        else\n        {\n            this._log.info(\"Starting in Unpaired State\");\n            this._currentStatus = SpiStatus.Unpaired;\n        } \n    }\n\n    // <summary>\n    // Allows you to set the PosId which identifies this instance of your POS.\n    // Can only be called in thge Unpaired state. \n    // </summary>\n    SetPosId(posId)\n    {\n        if (this.CurrentStatus != SpiStatus.Unpaired)\n            return false;\n\n        this._posId = posId;\n        this._spiMessageStamp.PosId = posId;\n        return true;\n    }\n\n    // <summary>\n    // Allows you to set the PinPad address. Sometimes the PinPad might change IP address \n    // (we recommend reserving static IPs if possible).\n    // Either way you need to allow your User to enter the IP address of the PinPad.\n    // </summary>\n    SetEftposAddress(address)\n    {\n        if (this.CurrentStatus == SpiStatus.PairedConnected) {\n            return false;\n        }\n\n        this._eftposAddress = \"ws://\" + address;\n        this._conn.Address = this._eftposAddress;\n        return true;\n    }\n\n    /// <summary>\n    /// Invoke ResolveDeviceIpAddress(). Once invoked, if Ip address changes it will trigger\n    /// _deviceIpChanged event.\n    /// </summary>\n    GetDeviceIpAddress(deviceIpAddressRequest)\n    {\n        if (this.CurrentStatus == SpiStatus.PairedConnected)\n            return;\n\n        // overwrite existing values with new request\n        this._serialNumber = deviceIpAddressRequest.SerialNumber;\n        this._deviceApiKey = deviceIpAddressRequest.ApiKey;\n\n        this.ResolveDeviceIpAddress();\n    }\n\n    /**\n     * Sets values used to identify the POS software to the EFTPOS terminal.\n     * Must be set before starting!\n     *\n     * @param posVendorId Vendor identifier of the POS itself.\n     * @param posVersion  Version string of the POS itself.\n     */\n    SetPosInfo(posVendorId, posVersion)\n    {\n        this._posVendorId = posVendorId;\n        this._posVersion = posVersion;\n    }\n\n    // <summary>\n    // Call this one when a flow is finished and you want to go back to idle state.\n    // Typically when your user clicks the \"OK\" bubtton to acknowldge that pairing is\n    // finished, or that transaction is finished.\n    // When true, you can dismiss the flow screen and show back the idle screen.\n    // </summary>\n    // <returns>true means we have moved back to the Idle state. false means current flow was not finished yet.</returns>\n    AckFlowEndedAndBackToIdle()\n    {\n        if (this.CurrentFlow == SpiFlow.Idle)\n            return true; // already idle\n\n        if (this.CurrentFlow == SpiFlow.Pairing && this.CurrentPairingFlowState.Finished)\n        {\n            this.CurrentFlow = SpiFlow.Idle;\n            return true;\n        }\n        \n        if (this.CurrentFlow == SpiFlow.Transaction && this.CurrentTxFlowState.Finished)\n        {\n            this.CurrentFlow = SpiFlow.Idle;\n            return true;\n        }\n\n        return false;\n    }\n\n    static GetVersion()\n    {\n        return SPI_VERSION;\n    }\n    // endregion\n\n    // <summary>\n    // This will connect to the Eftpos and start the pairing process.\n    // Only call this if you are in the Unpaired state.\n    // Subscribe to the PairingFlowStateChanged event to get updates on the pairing process.\n    // </summary>\n    // <returns>Whether pairing has initiated or not</returns>\n    Pair()\n    {\n        if (this.CurrentStatus != SpiStatus.Unpaired) {\n            this._log.warn(\"Tried to Pair but we're already so.\");\n            return false;\n        }\n\n        if (!this._posId || !this._eftposAddress)\n        {\n            this._log.warn(\"Tried to Pair but missing posId or eftposAddress\");\n            return false;\n        }\n\n        this.CurrentFlow = SpiFlow.Pairing;\n        this.CurrentPairingFlowState = new PairingFlowState\n        ({\n            Successful: false,\n            Finished: false,\n            Message: \"Connecting...\",\n            AwaitingCheckFromEftpos: false,\n            AwaitingCheckFromPos: false,\n            ConfirmationCode: \"\"\n        });\n\n        document.dispatchEvent(new CustomEvent('PairingFlowStateChanged', {detail: this.CurrentPairingFlowState}));\n        this._conn.Connect(); // Non-Blocking\n        return true;\n    }\n\n    // <summary>\n    // Call this when your user clicks yes to confirm the pairing code on your \n    // screen matches the one on the Eftpos.\n    // </summary>\n    PairingConfirmCode()\n    {\n        if (!this.CurrentPairingFlowState.AwaitingCheckFromPos)\n        {\n            // We weren't expecting this\n            return;\n        }\n\n        this.CurrentPairingFlowState.AwaitingCheckFromPos = false;\n        if (this.CurrentPairingFlowState.AwaitingCheckFromEftpos)\n        {\n            // But we are still waiting for confirmation from Eftpos side.\n            this._log.info(\"Pair Code Confirmed from POS side, but am still waiting for confirmation from Eftpos.\");\n            this.CurrentPairingFlowState.Message =\n                \"Click YES on EFTPOS if code is: \" + this.CurrentPairingFlowState.ConfirmationCode;\n            document.dispatchEvent(new CustomEvent('PairingFlowStateChanged', {detail: this.CurrentPairingFlowState}));\n        }\n        else\n        {\n            // Already confirmed from Eftpos - So all good now. We're Paired also from the POS perspective.\n            this._log.info(\"Pair Code Confirmed from POS side, and was already confirmed from Eftpos side. Pairing finalised.\");\n            this._onPairingSuccess();\n            this._onReadyToTransact();\n        }\n    }\n\n    // <summary>\n    // Call this if your user clicks CANCEL or NO during the pairing process.\n    // </summary>\n    PairingCancel()\n    {\n        if (this.CurrentFlow != SpiFlow.Pairing || this.CurrentPairingFlowState.Finished) {\n            return;\n        }\n\n        if (this.CurrentPairingFlowState.AwaitingCheckFromPos && !this.CurrentPairingFlowState.AwaitingCheckFromEftpos)\n        {\n            // This means that the Eftpos already thinks it's paired.\n            // Let's tell it to drop keys\n            this._send(new DropKeysRequest().ToMessage());\n        }\n        this._onPairingFailed();\n    }\n\n    // <summary>\n    // Call this when your uses clicks the Unpair button.\n    // This will disconnect from the Eftpos and forget the secrets.\n    // The CurrentState is then changed to Unpaired.\n    // Call this only if you are not yet in the Unpaired state.\n    // </summary>\n    Unpair()\n    {\n        if (this.CurrentStatus == SpiStatus.Unpaired) {\n            return false;\n        }\n\n        if (this.CurrentFlow != SpiFlow.Idle) {\n            return false;\n        }\n        \n        // Best effort letting the eftpos know that we're dropping the keys, so it can drop them as well.\n        this._send(new DropKeysRequest().ToMessage());\n        this._doUnpair();\n        return true;\n    }\n\n    // endregion\n\n    // region Transaction Methods\n\n    // <summary>\n    // Initiates a purchase transaction. Be subscribed to TxFlowStateChanged event to get updates on the process.\n    // </summary>\n    // <param name=\"posRefId\">Alphanumeric Identifier for your purchase.</param>\n    // <param name=\"amountCents\">Amount in Cents to charge</param>\n    // <returns>InitiateTxResult</returns>\n    InitiatePurchaseTx(posRefId, amountCents)\n    {\n        if (this.CurrentStatus == SpiStatus.Unpaired) {\n            return new InitiateTxResult(false, \"Not Paired\");\n        }\n\n        if (this.CurrentFlow != SpiFlow.Idle) {\n            return new InitiateTxResult(false, \"Not Idle\");\n        }\n\n        var purchaseRequest = PurchaseHelper.CreatePurchaseRequest(amountCents, posRefId);\n        purchaseRequest.Config = this.Config;\n        var purchaseMsg = purchaseRequest.ToMessage();\n        this.CurrentFlow = SpiFlow.Transaction;\n        this.CurrentTxFlowState = new TransactionFlowState(\n            posRefId, TransactionType.Purchase, amountCents, purchaseMsg,\n            `Waiting for EFTPOS connection to make payment request for ${amountCents / 100.0}`);\n        if (this._send(purchaseMsg))\n        {\n            this.CurrentTxFlowState.Sent(`Asked EFTPOS to accept payment for ${amountCents / 100.0}`);\n        }\n        \n        document.dispatchEvent(new CustomEvent('TxFlowStateChanged', {detail: this.CurrentTxFlowState}));\n        return new InitiateTxResult(true, \"Purchase Initiated\");\n    }\n\n    // <summary>\n    // Initiates a purchase transaction. Be subscribed to TxFlowStateChanged event to get updates on the process.\n    // <para>Tip and cashout are not allowed simultaneously.</para>\n    // </summary>\n    // <param name=\"posRefId\">An Unique Identifier for your Order/Purchase</param>\n    // <param name=\"purchaseAmount\">The Purchase Amount in Cents.</param>\n    // <param name=\"tipAmount\">The Tip Amount in Cents</param>\n    // <param name=\"cashoutAmount\">The Cashout Amount in Cents</param>\n    // <param name=\"promptForCashout\">Whether to prompt your customer for cashout on the Eftpos</param>\n    // <param name=\"options\">The Setting to set Header and Footer for the Receipt</param>\n    // <param name=\"surchargeAmount\">The Surcharge Amount in Cents</param>\n    // <returns>InitiateTxResult</returns>\n    InitiatePurchaseTxV2(posRefId, purchaseAmount, tipAmount, cashoutAmount, promptForCashout, options = {}, surchargeAmount = 0)\n    {\n        if (this.CurrentStatus == SpiStatus.Unpaired) return new InitiateTxResult(false, \"Not Paired\");\n\n        if (tipAmount > 0 && (cashoutAmount > 0 || promptForCashout)) return new InitiateTxResult(false, \"Cannot Accept Tips and Cashout at the same time.\");\n        \n        if (this.CurrentFlow != SpiFlow.Idle) return new InitiateTxResult(false, \"Not Idle\");\n        this.CurrentFlow = SpiFlow.Transaction;\n        \n        var purchase = PurchaseHelper.CreatePurchaseRequestV2(posRefId, purchaseAmount, tipAmount, cashoutAmount, promptForCashout, surchargeAmount);\n        purchase.Config = this.Config;\n        purchase.Options = options;\n        var purchaseMsg = purchase.ToMessage();\n        this.CurrentTxFlowState = new TransactionFlowState(\n            posRefId, TransactionType.Purchase, purchaseAmount, purchaseMsg,\n            `Waiting for EFTPOS connection to make payment request. ${purchase.AmountSummary()}`);\n        if (this._send(purchaseMsg))\n        {\n            this.CurrentTxFlowState.Sent(`Asked EFTPOS to accept payment for ${purchase.AmountSummary()}`);\n        }\n        \n        document.dispatchEvent(new CustomEvent('TxFlowStateChanged', {detail: this.CurrentTxFlowState}));\n        return new InitiateTxResult(true, \"Purchase Initiated\");\n    }\n\n    // <summary>\n    // Initiates a refund transaction. Be subscribed to TxFlowStateChanged event to get updates on the process.\n    // </summary>\n    // <param name=\"posRefId\">Alphanumeric Identifier for your refund.</param>\n    // <param name=\"amountCents\">Amount in Cents to charge</param>\n    // <param name=\"isSuppressMerchantPassword\">Merchant Password control in VAA</param>\n    // <returns>InitiateTxResult</returns>\n    InitiateRefundTx(posRefId, amountCents, isSuppressMerchantPassword = false)\n    {\n        if (this.CurrentStatus == SpiStatus.Unpaired) {\n            return new InitiateTxResult(false, \"Not Paired\");\n        }\n\n        if (this.CurrentFlow != SpiFlow.Idle) {\n            return new InitiateTxResult(false, \"Not Idle\");\n        }\n\n        var refundRequest = PurchaseHelper.CreateRefundRequest(amountCents, posRefId, isSuppressMerchantPassword);\n        refundRequest.Config = this.Config;\n        var refundMsg = refundRequest.ToMessage();\n        this.CurrentFlow = SpiFlow.Transaction;\n        this.CurrentTxFlowState = new TransactionFlowState(\n            posRefId, TransactionType.Refund, amountCents, refundMsg, \n            `Waiting for EFTPOS connection to make refund request for ${(amountCents / 100.0).toFixed(2)}`);\n        if (this._send(refundMsg))\n        {\n            this.CurrentTxFlowState.Sent(`Asked EFTPOS to refund ${(amountCents / 100.0).toFixed(2)}`);\n        }\n        \n        document.dispatchEvent(new CustomEvent('TxFlowStateChanged', {detail: this.CurrentTxFlowState}));\n        return new InitiateTxResult(true, \"Refund Initiated\");\n    }\n    \n    // <summary>\n    // Let the EFTPOS know whether merchant accepted or declined the signature\n    // </summary>\n    // <param name=\"accepted\">whether merchant accepted the signature from customer or not</param>\n    AcceptSignature(accepted)\n    {\n        if (this.CurrentFlow != SpiFlow.Transaction || this.CurrentTxFlowState.Finished || !this.CurrentTxFlowState.AwaitingSignatureCheck)\n        {\n            this._log.info(\"Asked to accept signature but I was not waiting for one.\");\n            return new MidTxResult(false, \"Asked to accept signature but I was not waiting for one.\");\n        }\n\n        this.CurrentTxFlowState.SignatureResponded(accepted ? \"Accepting Signature...\" : \"Declining Signature...\");\n        var sigReqMsg = this.CurrentTxFlowState.SignatureRequiredMessage;\n        this._send(accepted\n            ? new SignatureAccept(this.CurrentTxFlowState.PosRefId).ToMessage()\n            : new SignatureDecline(this.CurrentTxFlowState.PosRefId).ToMessage());\n        \n        document.dispatchEvent(new CustomEvent('TxFlowStateChanged', {detail: this.CurrentTxFlowState}));\n        return new MidTxResult(true, \"\");\n    }\n\n    // <summary>\n    // Submit the Code obtained by your user when phoning for auth. \n    // It will return immediately to tell you whether the code has a valid format or not. \n    // If valid==true is returned, no need to do anything else. Expect updates via standard callback.\n    // If valid==false is returned, you can show your user the accompanying message, and invite them to enter another code. \n    // </summary>\n    // <param name=\"authCode\">The code obtained by your user from the merchant call centre. It should be a 6-character alpha-numeric value.</param>\n    // <returns>Whether code has a valid format or not.</returns>\n    SubmitAuthCode(authCode)\n    {\n        if (authCode.length != 6)\n        {\n            return new SubmitAuthCodeResult(false, \"Not a 6-digit code.\");    \n        }\n                \n        if (this.CurrentFlow != SpiFlow.Transaction || this.CurrentTxFlowState.Finished || !this.CurrentTxFlowState.AwaitingPhoneForAuth)\n        {\n            this._log.info(\"Asked to send auth code but I was not waiting for one.\");\n            return new SubmitAuthCodeResult(false, \"Was not waiting for one.\");\n        }\n\n        this.CurrentTxFlowState.AuthCodeSent(`Submitting Auth Code ${authCode}`);\n        this._send(new AuthCodeAdvice(this.CurrentTxFlowState.PosRefId, authCode).ToMessage());\n        \n        document.dispatchEvent(new CustomEvent('TxFlowStateChanged', {detail: this.CurrentTxFlowState}));\n        return new SubmitAuthCodeResult(true, \"Valid Code.\");\n    }\n\n    // <summary>\n    // Attempts to cancel a Transaction. \n    // Be subscribed to TxFlowStateChanged event to see how it goes.\n    // Wait for the transaction to be finished and then see whether cancellation was successful or not.\n    // </summary>\n    // <returns>MidTxResult - false only if you called it in the wrong state</returns>\n    CancelTransaction()\n    {\n        if (this.CurrentFlow != SpiFlow.Transaction || this.CurrentTxFlowState.Finished)\n        {\n            this._log.info(\"Asked to cancel transaction but I was not in the middle of one.\");\n            return new MidTxResult(false, \"Asked to cancel transaction but I was not in the middle of one.\");\n        }\n\n        // TH-1C, TH-3C - Merchant pressed cancel\n        if (this.CurrentTxFlowState.RequestSent)\n        {\n            var cancelReq = new CancelTransactionRequest();\n            this.CurrentTxFlowState.Cancelling(\"Attempting to Cancel Transaction...\");\n            this._send(cancelReq.ToMessage());\n        }\n        else\n        {\n            // We Had Not Even Sent Request Yet. Consider as known failed.\n            this.CurrentTxFlowState.Failed(null, \"Transaction Cancelled. Request Had not even been sent yet.\");\n        }\n        \n        document.dispatchEvent(new CustomEvent('TxFlowStateChanged', {detail: this.CurrentTxFlowState}));\n        return new MidTxResult(true, \"\");\n    }\n\n    // <summary>\n    // Initiates a cashout only transaction. Be subscribed to TxFlowStateChanged event to get updates on the process.\n    // </summary>\n    // <param name=\"posRefId\">Alphanumeric Identifier for your transaction.</param>\n    // <param name=\"amountCents\">Amount in Cents to cash out</param>\n    // <param name=\"surchargeAmount\">The Surcharge Amount in Cents</param>\n    // <returns>InitiateTxResult</returns>\n    InitiateCashoutOnlyTx(posRefId, amountCents, surchargeAmount = 0)\n    {\n        if (this.CurrentStatus == SpiStatus.Unpaired) return new InitiateTxResult(false, \"Not Paired\");\n\n        if (this.CurrentFlow != SpiFlow.Idle) return new InitiateTxResult(false, \"Not Idle\");\n        var cashoutOnlyRequest = new CashoutOnlyRequest(amountCents, posRefId, surchargeAmount);\n        cashoutOnlyRequest.Config = this.Config;\n        var cashoutMsg = cashoutOnlyRequest.ToMessage();\n        this.CurrentFlow = SpiFlow.Transaction;\n        this.CurrentTxFlowState = new TransactionFlowState(\n            posRefId, TransactionType.CashoutOnly, amountCents, cashoutMsg,\n            `Waiting for EFTPOS connection to send cashout request for ${(amountCents / 100).toFixed(2)}`);\n        if (this._send(cashoutMsg))\n        {\n            this.CurrentTxFlowState.Sent(`Asked EFTPOS to do cashout for ${(amountCents / 100).toFixed(2)}`);\n        }\n        \n        document.dispatchEvent(new CustomEvent('TxFlowStateChanged', {detail: this.CurrentTxFlowState}));\n        return new InitiateTxResult(true, \"Cashout Initiated\");\n    }    \n\n    // <summary>\n    // Initiates a Mail Order / Telephone Order Purchase Transaction\n    // </summary>\n    // <param name=\"posRefId\">Alphanumeric Identifier for your transaction.</param>\n    // <param name=\"amountCents\">Amount in Cents</param>\n    // <param name=\"surchargeAmount\">The Surcharge Amount in Cents</param>\n    // <returns>InitiateTxResult</returns>\n    InitiateMotoPurchaseTx(posRefId, amountCents, surchargeAmount = 0)\n    {\n        if (this.CurrentStatus == SpiStatus.Unpaired) return new InitiateTxResult(false, \"Not Paired\");\n\n        if (this.CurrentFlow != SpiFlow.Idle) return new InitiateTxResult(false, \"Not Idle\");\n        var motoPurchaseRequest = new MotoPurchaseRequest(amountCents, posRefId, surchargeAmount);\n        motoPurchaseRequest.Config = this.Config;\n        var cashoutMsg = motoPurchaseRequest.ToMessage();\n        this.CurrentFlow = SpiFlow.Transaction;\n        this.CurrentTxFlowState = new TransactionFlowState(\n            posRefId, TransactionType.MOTO, amountCents, cashoutMsg,\n            `Waiting for EFTPOS connection to send MOTO request for ${(amountCents / 100).toFixed(2)}`);\n        if (this._send(cashoutMsg))\n        {\n            this.CurrentTxFlowState.Sent(`Asked EFTPOS do MOTO for ${(amountCents / 100).toFixed(2)}`);\n        }\n        \n        document.dispatchEvent(new CustomEvent('TxFlowStateChanged', {detail: this.CurrentTxFlowState}));\n        return new InitiateTxResult(true, \"MOTO Initiated\");\n    }\n\n    // <summary>\n    // Initiates a settlement transaction.\n    // Be subscribed to TxFlowStateChanged event to get updates on the process.\n    // </summary>\n    InitiateSettleTx(posRefId)\n    {\n        if (this.CurrentStatus == SpiStatus.Unpaired) {\n            return new InitiateTxResult(false, \"Not Paired\");\n        }\n\n        if (this.CurrentFlow != SpiFlow.Idle) {\n            return new InitiateTxResult(false, \"Not Idle\");\n        }\n\n        var settleRequestMsg = new SettleRequest(RequestIdHelper.Id(\"settle\")).ToMessage();\n        this.CurrentFlow = SpiFlow.Transaction;\n        this.CurrentTxFlowState = new TransactionFlowState(\n            posRefId, TransactionType.Settle, 0, settleRequestMsg, \n            `Waiting for EFTPOS connection to make a settle request`);\n\n        if (this._send(settleRequestMsg))\n        {\n            this.CurrentTxFlowState.Sent(`Asked EFTPOS to settle.`);\n        }\n        \n        document.dispatchEvent(new CustomEvent('TxFlowStateChanged', {detail: this.CurrentTxFlowState}));\n        return new InitiateTxResult(true, \"Settle Initiated\");   \n    }\n\n    // <summary>\n    // </summary>\n    InitiateSettlementEnquiry(posRefId)\n    {\n        if (this.CurrentStatus == SpiStatus.Unpaired) return new InitiateTxResult(false, \"Not Paired\");\n\n        if (this.CurrentFlow != SpiFlow.Idle) return new InitiateTxResult(false, \"Not Idle\");\n        var stlEnqMsg = new SettlementEnquiryRequest(RequestIdHelper.Id(\"stlenq\")).ToMessage();\n        this.CurrentFlow = SpiFlow.Transaction;\n        this.CurrentTxFlowState = new TransactionFlowState(\n            posRefId, TransactionType.SettlementEnquiry, 0, stlEnqMsg,\n            \"Waiting for EFTPOS connection to make a settlement enquiry\");\n        if (this._send(stlEnqMsg))\n        {\n            this.CurrentTxFlowState.Sent(\"Asked EFTPOS to make a settlement enquiry.\");\n        }\n        \n        document.dispatchEvent(new CustomEvent('TxFlowStateChanged', {detail: this.CurrentTxFlowState}));\n        return new InitiateTxResult(true, \"Settle Initiated\");   \n    }\n\n    // <summary>\n    // Initiates a Get Last Transaction. Use this when you want to retrieve the most recent transaction\n    // that was processed by the Eftpos.\n    // Be subscribed to TxFlowStateChanged event to get updates on the process.\n    // </summary>\n    InitiateGetLastTx()\n    {\n        if (this.CurrentStatus == SpiStatus.Unpaired) {\n            return new InitiateTxResult(false, \"Not Paired\");\n        }\n\n        if (this.CurrentFlow != SpiFlow.Idle) {\n            return new InitiateTxResult(false, \"Not Idle\");\n        }\n\n        var gltRequestMsg = new GetLastTransactionRequest().ToMessage();\n        this.CurrentFlow = SpiFlow.Transaction;\n        var posRefId = gltRequestMsg.Id; // GetLastTx is not trying to get anything specific back. So we just use the message id.\n        this.CurrentTxFlowState = new TransactionFlowState(\n            posRefId, TransactionType.GetLastTransaction, 0, gltRequestMsg, \n            \"Waiting for EFTPOS connection to make a Get-Last-Transaction request.\");\n        \n        if (this._send(gltRequestMsg))\n        {\n            this.CurrentTxFlowState.Sent(`Asked EFTPOS for last transaction.`);\n        }\n    \n        document.dispatchEvent(new CustomEvent('TxFlowStateChanged', {detail: this.CurrentTxFlowState}));\n        return new InitiateTxResult(true, \"GLT Initiated\");   \n    }\n\n    // <summary>\n    // This is useful to recover from your POS crashing in the middle of a transaction.\n    // When you restart your POS, if you had saved enough state, you can call this method to recover the client library state.\n    // You need to have the posRefId that you passed in with the original transaction, and the transaction type.\n    // This method will return immediately whether recovery has started or not.\n    // If recovery has started, you need to bring up the transaction modal to your user a be listening to TxFlowStateChanged.\n    // </summary>\n    // <param name=\"posRefId\">The is that you had assigned to the transaction that you are trying to recover.</param>\n    // <param name=\"txType\">The transaction type.</param>\n    // <returns></returns>\n    InitiateRecovery(posRefId, txType)\n    {\n        if (this.CurrentStatus == SpiStatus.Unpaired) return new InitiateTxResult(false, \"Not Paired\");\n    \n        if (this.CurrentFlow != SpiFlow.Idle) return new InitiateTxResult(false, \"Not Idle\");\n        \n        this.CurrentFlow = SpiFlow.Transaction;\n        \n        var gltRequestMsg = new GetLastTransactionRequest().ToMessage();\n        this.CurrentTxFlowState = new TransactionFlowState(\n            posRefId, txType, 0, gltRequestMsg, \n            \"Waiting for EFTPOS connection to attempt recovery.\");\n        \n        if (this._send(gltRequestMsg))\n        {\n            this.CurrentTxFlowState.Sent(`Asked EFTPOS to recover state.`);\n        }\n    \n        document.dispatchEvent(new CustomEvent('TxFlowStateChanged', {detail: this.CurrentTxFlowState}));\n        return new InitiateTxResult(true, \"Recovery Initiated\");\n    }\n\n    // <summary>\n    // GltMatch attempts to conclude whether a gltResponse matches an expected transaction and returns\n    // the outcome. \n    // If Success/Failed is returned, it means that the gtlResponse did match, and that transaction was succesful/failed.\n    // If Unknown is returned, it means that the gltResponse does not match the expected transaction. \n    // </summary>\n    // <param name=\"gltResponse\">The GetLastTransactionResponse message to check</param>\n    // <param name=\"posRefId\">The Reference Id that you passed in with the original request.</param>\n\n    // <returns></returns>\n    GltMatch(gltResponse, posRefId, ...deprecatedArgs) \n    {\n        // Obsolete method call check\n        // Old interface: GltMatch(GetLastTransactionResponse gltResponse, TransactionType expectedType, int expectedAmount, DateTime requestTime, string posRefId)\n        if(deprecatedArgs.length) {\n            if(deprecatedArgs.length == 2) {\n                this._log.info(\"Obsolete method call detected: Use GltMatch(gltResponse, posRefId)\");\n                return this.GltMatch(gltResponse, deprecatedArgs[2]);\n            } else {\n                throw new Error(\"Obsolete method call with unknown args: Use GltMatch(GetLastTransactionResponse gltResponse, string posRefId)\");\n            }\n        }\n\n        this._log.info(`GLT CHECK: PosRefId: ${posRefId}->${gltResponse.GetPosRefId()}`);\n\n        if (!posRefId == gltResponse.GetPosRefId())\n        {\n            return SuccessState.Unknown;\n        }\n\n        return gltResponse.GetSuccessState();\n    }\n\n    PrintReceipt(key, payload)\n    {\n        this._send(new PrintingRequest(key, payload).toMessage());\n    }\n\n    \n    GetTerminalStatus()\n    {\n        this._send(new TerminalStatusRequest().ToMessage());\n    }\n\n    // endregion\n        \n    // region Internals for Pairing Flow\n\n    // <summary>\n    // Handling the 2nd interaction of the pairing process, i.e. an incoming KeyRequest.\n    // </summary>\n    // <param name=\"m\">incoming message</param>\n    _handleKeyRequest(m)\n    {\n        this.CurrentPairingFlowState.Message = \"Negotiating Pairing...\";\n        document.dispatchEvent(new CustomEvent('PairingFlowStateChanged', {detail: this.CurrentPairingFlowState}));\n\n        // Use the helper. It takes the incoming request, and generates the secrets and the response.\n        var ph      = new PairingHelper();\n        var result  = ph.GenerateSecretsAndKeyResponse(new KeyRequest(m));\n        this._secrets = result.Secrets; // we now have secrets, although pairing is not fully finished yet.\n        this._spiMessageStamp.Secrets = this._secrets; // updating our stamp with the secrets so can encrypt messages later.\n        this._send(result.KeyResponse.ToMessage()); // send the key_response, i.e. interaction 3 of pairing.\n    }\n\n    // <summary>\n    // Handling the 4th interaction of the pairing process i.e. an incoming KeyCheck.\n    // </summary>\n    // <param name=\"m\"></param>\n    _handleKeyCheck(m)\n    {\n        var keyCheck = new KeyCheck(m);\n        this.CurrentPairingFlowState.ConfirmationCode = keyCheck.ConfirmationCode;\n        this.CurrentPairingFlowState.AwaitingCheckFromEftpos = true;\n        this.CurrentPairingFlowState.AwaitingCheckFromPos = true;\n        this.CurrentPairingFlowState.Message = \"Confirm that the following Code is showing on the Terminal\";\n        document.dispatchEvent(new CustomEvent('PairingFlowStateChanged', {detail: this.CurrentPairingFlowState}));\n    }\n\n    // <summary>\n    // Handling the 5th and final interaction of the pairing process, i.e. an incoming PairResponse\n    // </summary>\n    // <param name=\"m\"></param>\n    _handlePairResponse(m)\n    {\n        var pairResp = new PairResponse(m);\n\n        this.CurrentPairingFlowState.AwaitingCheckFromEftpos = false;\n        if (pairResp.Success)\n        {\n            if (this.CurrentPairingFlowState.AwaitingCheckFromPos)\n            {\n                // Still Waiting for User to say yes on POS\n                this._log.info(\"Got Pair Confirm from Eftpos, but still waiting for use to confirm from POS.\");\n                this.CurrentPairingFlowState.Message = \"Confirm that the following Code is what the EFTPOS showed\";\n                document.dispatchEvent(new CustomEvent('PairingFlowStateChanged', {detail: this.CurrentPairingFlowState}));\n            }\n            else\n            {\n                this._log.info(\"Got Pair Confirm from Eftpos, and already had confirm from POS. Now just waiting for first pong.\");\n                this._onPairingSuccess();\n            }\n            // I need to ping/login even if the pos user has not said yes yet, \n            // because otherwise within 5 seconds connectiong will be dropped by eftpos.\n            this._startPeriodicPing();\n        }\n        else\n        {\n            this._onPairingFailed();\n        }\n    }\n\n    _handleDropKeysAdvice(m)\n    {\n        this._log.Info(\"Eftpos was Unpaired. I shall unpair from my end as well.\");\n        this._doUnpair();\n    }\n\n    _onPairingSuccess()\n    {\n        this.CurrentPairingFlowState.Successful = true;\n        this.CurrentPairingFlowState.Finished = true;\n        this.CurrentPairingFlowState.Message = \"Pairing Successful!\";\n        this.CurrentStatus = SpiStatus.PairedConnected;\n        document.dispatchEvent(new CustomEvent('SecretsChanged', {detail: this._secrets}));\n        document.dispatchEvent(new CustomEvent('PairingFlowStateChanged', {detail: this.CurrentPairingFlowState}));\n    }\n\n    _onPairingFailed()\n    {\n        this._secrets = null;\n        this._spiMessageStamp.Secrets = null;\n        this._conn.Disconnect();\n\n        this.CurrentStatus = SpiStatus.Unpaired;\n        this.CurrentPairingFlowState.Message = \"Pairing Failed\";\n        this.CurrentPairingFlowState.Finished = true;\n        this.CurrentPairingFlowState.Successful = false;\n        this.CurrentPairingFlowState.AwaitingCheckFromPos = false;\n        document.dispatchEvent(new CustomEvent('PairingFlowStateChanged', {detail: this.CurrentPairingFlowState}));\n    }\n\n    _doUnpair()\n    {\n        this.CurrentStatus = SpiStatus.Unpaired;\n        this._conn.Disconnect();\n        this._secrets = null;\n        this._spiMessageStamp.Secrets = null;\n        document.dispatchEvent(new CustomEvent('SecretsChanged', {detail: this._secrets}));\n    }\n\n    // <summary>\n    // Sometimes the server asks us to roll our secrets.\n    // </summary>\n    // <param name=\"m\"></param>\n    _handleKeyRollingRequest(m)\n    {\n        // we calculate the new ones...\n        var krRes = KeyRollingHelper.PerformKeyRolling(m, this._secrets);\n        this._secrets = krRes.NewSecrets; // and update our secrets with them\n        this._spiMessageStamp.Secrets = this._secrets; // and our stamp\n        this._send(krRes.KeyRollingConfirmation); // and we tell the server that all is well.\n        document.dispatchEvent(new CustomEvent('SecretsChanged', {detail: this._secrets}));\n    }\n\n    // <summary>\n    // The PinPad server will send us this message when a customer signature is reqired.\n    // We need to ask the customer to sign the incoming receipt.\n    // And then tell the pinpad whether the signature is ok or not.\n    // </summary>\n    // <param name=\"m\"></param>\n    _handleSignatureRequired(m)\n    {\n        var incomingPosRefId = m.Data.pos_ref_id;\n        if (this.CurrentFlow != SpiFlow.Transaction || this.CurrentTxFlowState.Finished || !this.CurrentTxFlowState.PosRefId == incomingPosRefId)\n        {\n            this._log.info(`Received Signature Required but I was not waiting for one. Incoming Pos Ref ID: ${incomingPosRefId}`);\n            return;\n        }\n        this.CurrentTxFlowState.SignatureRequired(new SignatureRequired(m), \"Ask Customer to Sign the Receipt\");\n    \n        document.dispatchEvent(new CustomEvent('TxFlowStateChanged', {detail: this.CurrentTxFlowState}));\n    }\n\n    // <summary>\n    // The PinPad server will send us this message when an auth code is required.\n    // </summary>\n    // <param name=\"m\"></param>\n    _handleAuthCodeRequired(m)\n    {\n        var incomingPosRefId = m.Data.pos_ref_id;\n        if (this.CurrentFlow != SpiFlow.Transaction || this.CurrentTxFlowState.Finished || !this.CurrentTxFlowState.PosRefId == incomingPosRefId)\n        {\n            _log.Info(`Received Auth Code Required but I was not waiting for one. Incoming Pos Ref ID: ${incomingPosRefId}`);\n            return;\n        }\n        var phoneForAuthRequired = new PhoneForAuthRequired(m);\n        var msg = `Auth Code Required. Call ${phoneForAuthRequired.GetPhoneNumber()} and quote merchant id ${phoneForAuthRequired.GetMerchantId()}`;\n        this.CurrentTxFlowState.PhoneForAuthRequired(phoneForAuthRequired, msg);\n    \n        document.dispatchEvent(new CustomEvent('TxFlowStateChanged', {detail: this.CurrentTxFlowState}));\n    }\n\n    // <summary>\n    // The PinPad server will reply to our PurchaseRequest with a PurchaseResponse.\n    // </summary>\n    // <param name=\"m\"></param>\n    _handlePurchaseResponse(m)\n    {\n        var incomingPosRefId = m.Data.pos_ref_id;\n        if (this.CurrentFlow != SpiFlow.Transaction || this.CurrentTxFlowState.Finished || !this.CurrentTxFlowState.PosRefId == incomingPosRefId)\n        {\n            this._log.info(`Received Purchase response but I was not waiting for one. Incoming Pos Ref ID: ${incomingPosRefId}\"`);\n            return;\n        }\n        // TH-1A, TH-2A\n        \n        this.CurrentTxFlowState.Completed(m.GetSuccessState(), m, \"Purchase Transaction Ended.\");\n        // TH-6A, TH-6E\n        \n        document.dispatchEvent(new CustomEvent('TxFlowStateChanged', {detail: this.CurrentTxFlowState}));\n    }\n\n    // <summary>\n    // The PinPad server will reply to our CashoutOnlyRequest with a CashoutOnlyResponse.\n    // </summary>\n    // <param name=\"m\"></param>\n    _handleCashoutOnlyResponse(m)\n    {\n        var incomingPosRefId = m.Data.pos_ref_id;\n        if (this.CurrentFlow != SpiFlow.Transaction || this.CurrentTxFlowState.Finished || !this.CurrentTxFlowState.PosRefId == incomingPosRefId)\n        {\n            this._log.info(`Received Cashout Response but I was not waiting for one. Incoming Pos Ref ID: ${incomingPosRefId}`);\n            return;\n        }\n        // TH-1A, TH-2A\n        \n        this.CurrentTxFlowState.Completed(m.GetSuccessState(), m, \"Cashout Transaction Ended.\");\n        // TH-6A, TH-6E\n        \n        document.dispatchEvent(new CustomEvent('TxFlowStateChanged', {detail: this.CurrentTxFlowState}));\n    }\n\n    // <summary>\n    // The PinPad server will reply to our MotoPurchaseRequest with a MotoPurchaseResponse.\n    // </summary>\n    // <param name=\"m\"></param>\n    _handleMotoPurchaseResponse(m)\n    {\n        var incomingPosRefId = m.Data.pos_ref_id;\n        if (this.CurrentFlow != SpiFlow.Transaction || this.CurrentTxFlowState.Finished || !this.CurrentTxFlowState.PosRefId == incomingPosRefId)\n        {\n            this._log.info(`Received Moto Response but I was not waiting for one. Incoming Pos Ref ID: ${incomingPosRefId}`);\n            return;\n        }\n        // TH-1A, TH-2A\n        \n        this.CurrentTxFlowState.Completed(m.GetSuccessState(), m, \"Moto Transaction Ended.\");\n        // TH-6A, TH-6E\n        \n        document.dispatchEvent(new CustomEvent('TxFlowStateChanged', {detail: this.CurrentTxFlowState}));\n    }   \n\n    // <summary>\n    // The PinPad server will reply to our RefundRequest with a RefundResponse.\n    // </summary>\n    // <param name=\"m\"></param>\n    _handleRefundResponse(m)\n    {\n        var incomingPosRefId = m.Data.pos_ref_id;\n        if (this.CurrentFlow != SpiFlow.Transaction || this.CurrentTxFlowState.Finished | !this.CurrentTxFlowState.PosRefId == incomingPosRefId)\n        {\n            this._log.info(`Received Refund response but I was not waiting for this one. Incoming Pos Ref ID: ${incomingPosRefId}`);\n            return;\n        }\n        // TH-1A, TH-2A\n        \n        this.CurrentTxFlowState.Completed(m.GetSuccessState(), m, \"Refund Transaction Ended.\");\n        // TH-6A, TH-6E\n        \n        document.dispatchEvent(new CustomEvent('TxFlowStateChanged', {detail: this.CurrentTxFlowState}));\n    }\n\n    // <summary>\n    // TODO: Handle the Settlement Response received from the PinPad\n    // </summary>\n    // <param name=\"m\"></param>\n    HandleSettleResponse(m)\n    {\n        if (this.CurrentFlow != SpiFlow.Transaction || this.CurrentTxFlowState.Finished)\n        {\n            this._log.info(`Received Settle response but I was not waiting for one. ${m.DecryptedJson}`);\n            return;\n        }\n        // TH-1A, TH-2A\n        \n        this.CurrentTxFlowState.Completed(m.GetSuccessState(), m, \"Settle Transaction Ended.\");\n        // TH-6A, TH-6E\n    \n        document.dispatchEvent(new CustomEvent('TxFlowStateChanged', {detail: this.CurrentTxFlowState}));\n    }\n\n    // <summary>\n    // Handle the Settlement Enquiry Response received from the PinPad\n    // </summary>\n    // <param name=\"m\"></param>\n    _handleSettlementEnquiryResponse(m)\n    {\n        if (this.CurrentFlow != SpiFlow.Transaction || this.CurrentTxFlowState.Finished)\n        {\n            this._log.info(`Received Settlement Enquiry response but I was not waiting for one. ${m.DecryptedJson}`);\n            return;\n        }\n        // TH-1A, TH-2A\n        \n        this.CurrentTxFlowState.Completed(m.GetSuccessState(), m, \"Settlement Enquiry Ended.\");\n        // TH-6A, TH-6E\n        \n        document.dispatchEvent(new CustomEvent('TxFlowStateChanged', {detail: this.CurrentTxFlowState}));\n    }\n\n    // <summary>\n    // Sometimes we receive event type \"error\" from the server, such as when calling cancel_transaction and there is no transaction in progress.\n    // </summary>\n    // <param name=\"m\"></param>\n    _handleErrorEvent(m)\n    {\n        if (this.CurrentFlow == SpiFlow.Transaction\n            && !this.CurrentTxFlowState.Finished\n            && this.CurrentTxFlowState.AttemptingToCancel\n            && m.GetError() == \"NO_TRANSACTION\")\n        {\n            // TH-2E\n            this._log.info(`Was trying to cancel a transaction but there is nothing to cancel. Calling GLT to see what's up`);\n            this._callGetLastTransaction();\n        }\n        else\n        {\n            this._log.info(`Received Error Event But Don't know what to do with it. ${m.DecryptedJson}`);\n        }\n    }\n\n    // <summary>\n    // When the PinPad returns to us what the Last Transaction was.\n    // </summary>\n    // <param name=\"m\"></param>\n    _handleGetLastTransactionResponse(m)\n    {\n        var txState = this.CurrentTxFlowState;\n        if (this.CurrentFlow != SpiFlow.Transaction || txState.Finished)\n        {\n            // We were not in the middle of a transaction, who cares?\n            return;\n        }\n\n        // TH-4 We were in the middle of a transaction.\n        // Let's attempt recovery. This is step 4 of Transaction Processing Handling\n        this._log.info(`Got Last Transaction..`);\n        txState.GotGltResponse();\n        var gtlResponse = new GetLastTransactionResponse(m);\n        txState.GLTResponsePosRefId = gtlResponse.GetPosRefId();\n        if (!gtlResponse.WasRetrievedSuccessfully())\n        {\n            if (gtlResponse.IsStillInProgress(txState.PosRefId))\n            {\n                // TH-4E - Operation In Progress\n\n                if (gtlResponse.IsWaitingForSignatureResponse() && !txState.AwaitingSignatureCheck)\n                {\n                    this._log.info(\"Eftpos is waiting for us to send it signature accept/decline, but we were not aware of this. \" +\n                              \"The user can only really decline at this stage as there is no receipt to print for signing.\");\n                    this.CurrentTxFlowState.SignatureRequired(new SignatureRequired(txState.PosRefId, m.Id, \"MISSING RECEIPT\\n DECLINE AND TRY AGAIN.\"), \"Recovered in Signature Required but we don't have receipt. You may Decline then Retry.\");\n                }\n                else if (gtlResponse.IsWaitingForAuthCode() && !txState.AwaitingPhoneForAuth)\n                {\n                    this._log.info(\"Eftpos is waiting for us to send it auth code, but we were not aware of this. \" +\n                              \"We can only cancel the transaction at this stage as we don't have enough information to recover from this.\");\n                    this.CurrentTxFlowState.PhoneForAuthRequired(new PhoneForAuthRequired(txState.PosRefId, m.Id, \"UNKNOWN\", \"UNKNOWN\"), \"Recovered mid Phone-For-Auth but don't have details. You may Cancel then Retry.\");\n                }\n                else\n                {\n                    this._log.info(\"Operation still in progress... stay waiting.\");\n                    // No need to publish txFlowStateChanged. Can return;\n                    return;\n                }\n            }\n            else if (gtlResponse.WasTimeOutOfSyncError())\n            {\n                // Let's not give up based on a TOOS error.\n                // Let's log it, and ignore it. \n                this._log.info(`Time-Out-Of-Sync error in Get Last Transaction response. Let's ignore it and we'll try again.`);\n                // No need to publish txFlowStateChanged. Can return;\n                return;\n            }\n            else\n            {\n                // TH-4X - Unexpected Response when recovering\n                this._log.info(`Unexpected Response in Get Last Transaction during - Received posRefId:${gtlResponse.GetPosRefId()} Error:${m.GetError()}`);\n                txState.UnknownCompleted(\"Unexpected Error when recovering Transaction Status. Check EFTPOS. \");\n            }\n        }\n        else\n        {\n            if (txState.Type == TransactionType.GetLastTransaction)\n            {\n                // THIS WAS A PLAIN GET LAST TRANSACTION REQUEST, NOT FOR RECOVERY PURPOSES.\n                this._log.info(\"Retrieved Last Transaction as asked directly by the user.\");\n                gtlResponse.CopyMerchantReceiptToCustomerReceipt();\n                txState.Completed(m.GetSuccessState(), m, \"Last Transaction Retrieved\");\n            }\n            else\n            {\n                // TH-4A - Let's try to match the received last transaction against the current transaction\n                var successState = this.GltMatch(gtlResponse, txState.PosRefId);\n                if (successState == SuccessState.Unknown)\n                {\n                    // TH-4N: Didn't Match our transaction. Consider Unknown State.\n                    this._log.info(\"Did not match transaction.\");\n                    txState.UnknownCompleted(\"Failed to recover Transaction Status. Check EFTPOS. \");\n                }\n                else\n                {\n                    // TH-4Y: We Matched, transaction finished, let's update ourselves\n                    gtlResponse.CopyMerchantReceiptToCustomerReceipt();\n                    txState.Completed(successState, m, \"Transaction Ended.\");\n                }\n            } \n        }\n        document.dispatchEvent(new CustomEvent('TxFlowStateChanged', {detail: txState}));\n    }\n\n    //When the transaction cancel response is returned.\n    _handleCancelTransactionResponse(m)\n    {\n        var incomingPosRefId = m.Data.pos_ref_id;\n        if (this.CurrentFlow != SpiFlow.Transaction || this.CurrentTxFlowState.Finished || !this.CurrentTxFlowState.PosRefId == incomingPosRefId)\n        {\n            this._log.Info(`Received Cancel Required but I was not waiting for one. Incoming Pos Ref ID: ${incomingPosRefId}`);\n            return;\n        }\n\n        var txState = this.CurrentTxFlowState;\n        var cancelResponse = new CancelTransactionResponse(m);\n\n        if (cancelResponse.Success) return;\n\n        this._log.Warn(\"Failed to cancel transaction: reason=\" + cancelResponse.GetErrorReason() + \", detail=\" + cancelResponse.GetErrorDetail());\n\n        txState.CancelFailed(\"Failed to cancel transaction: \" + cancelResponse.GetErrorDetail() + \". Check EFTPOS.\");\n    \n        document.dispatchEvent(new CustomEvent('TxFlowStateChanged', {detail: txState}));\n    }\n\n    _handleSetPosInfoResponse(m)\n    {\n        var response = new SetPosInfoResponse(m);\n        if (response.isSuccess())\n        {\n            this._hasSetInfo = true;\n            this._log.Info(\"Setting POS info successful\");\n        }\n        else\n        {\n            this._log.Warn(\"Setting POS info failed: reason=\" + response.getErrorReason() + \", detail=\" + response.getErrorDetail());\n        }\n    }\n\n    _startTransactionMonitoringThread()\n    {\n        var needsPublishing = false;\n    \n        var txState = this.CurrentTxFlowState;\n        if (this.CurrentFlow == SpiFlow.Transaction && !txState.Finished)\n        {\n            var state = txState;\n            if (state.AttemptingToCancel && Date.now() > state.CancelAttemptTime + this._maxWaitForCancelTx)\n            {\n                // TH-2T - too long since cancel attempt - Consider unknown\n                this._log.info(`Been too long waiting for transaction to cancel.`);\n                txState.UnknownCompleted(`Waited long enough for Cancel Transaction result. Check EFTPOS. `);\n                needsPublishing = true;\n            }\n            else if (state.RequestSent && Date.now() > state.LastStateRequestTime + this._checkOnTxFrequency)\n            {\n                // TH-1T, TH-4T - It's been a while since we received an update, let's call a GLT\n                this._log.info(`Checking on our transaction. Last we asked was at ${state.LastStateRequestTime}...`);\n                txState.CallingGlt();\n                this._callGetLastTransaction();\n            }\n        }\n        \n        if (needsPublishing) {\n            document.dispatchEvent(new CustomEvent('TxFlowStateChanged', {detail: this.CurrentTxFlowState}));\n        }\n\n        setTimeout(() => this._startTransactionMonitoringThread(), this._txMonitorCheckFrequency);\n    }\n\n    PrintingResponse(m) {\n        throw new Exception('Method not implemented. Please overwrite this method in your POS');\n    }\n\n    TerminalStatusResponse(m) {\n        throw new Exception('Method not implemented. Please overwrite this method in your POS');\n    }\n\n    BatteryLevelChanged(m) {\n        throw new Exception('Method not implemented. Please overwrite this method in your POS');\n    }\n\n    _handlePrintingResponse(m)\n    {\n        this.PrintingResponse(m);\n    }\n\n    _handleTerminalStatusResponse(m)\n    {\n        this.TerminalStatusResponse(m);\n    }\n\n    _handleBatteryLevelChanged(m)\n    {\n        this.BatteryLevelChanged(m);\n    }\n\n    // endregion\n        \n    // region Internals for Connection Management\n\n    _resetConn()\n    {\n        // Setup the Connection\n        this._conn = new Connection();\n        this._conn.Address = this._eftposAddress;\n\n        // Register our Event Handlers\n        document.addEventListener('ConnectionStatusChanged', (e) => this._onSpiConnectionStatusChanged(e.detail));\n        document.addEventListener('MessageReceived', (e) => this._onSpiMessageReceived(e.detail));\n        document.addEventListener('ErrorReceived', (e) => this._onWsErrorReceived(e.detail));\n    }\n\n    // <summary>\n    // This method will be called when the connection status changes.\n    // You are encouraged to display a PinPad Connection Indicator on the POS screen.\n    // </summary>\n    // <param name=\"state\"></param>\n    _onSpiConnectionStatusChanged(state)\n    {\n        switch (state.ConnectionState)\n        {\n            case ConnectionState.Connecting:\n                this._log.info(`I'm Connecting to the Eftpos at ${this._eftposAddress}...`);\n                break;\n\n            case ConnectionState.Connected:\n                this._retrySinceLastDeviceIpAddressResolution = 0;\n\n                if (this.CurrentFlow == SpiFlow.Pairing && this.CurrentStatus == SpiStatus.Unpaired)\n                {\n                    this.CurrentPairingFlowState.Message = \"Requesting to Pair...\";\n                    document.dispatchEvent(new CustomEvent('PairingFlowStateChanged', {detail: this.CurrentPairingFlowState}));\n                    var pr = PairingHelper.NewPairRequest();\n                    this._send(pr.ToMessage());\n                }\n                else\n                {\n                    this._log.info(`I'm Connected to ${this._eftposAddress}...`);\n                    this._spiMessageStamp.Secrets = this._secrets;\n                    this._startPeriodicPing();\n                }\n                break;\n\n            case ConnectionState.Disconnected:\n                // Let's reset some lifecycle related to connection state, ready for next connection\n                this._log.info(`I'm disconnected from ${this._eftposAddress}...`);\n                this._mostRecentPingSent = null;\n                this._mostRecentPongReceived = null;\n                this._missedPongsCount = 0;\n                this._stopPeriodicPing();\n\n                if (this.CurrentStatus != SpiStatus.Unpaired)\n                {\n                    this.CurrentStatus = SpiStatus.PairedConnecting;\n\n                    if (this.CurrentFlow == SpiFlow.Transaction && !this.CurrentTxFlowState.Finished)\n                    {\n                        // we're in the middle of a transaction, just so you know!\n                        // TH-1D\n                        this._log.info(`Lost connection in the middle of a transaction...`);\n                    }\n                    \n                    if (this._conn == null) return; // This means the instance has been disposed. Aborting.\n                    \n                    if (this._retrySinceLastDeviceIpAddressResolution >= this._retryBeforeResolvingDeviceIpAddress)\n                    {\n                        this.ResolveDeviceIpAddress();\n                        this._retrySinceLastDeviceIpAddressResolution = 0;\n                    }\n                    else\n                    {\n                        this._retrySinceLastDeviceIpAddressResolution += 1;\n                        this._log.info(`Will try to reconnect in 5s...`);\n                        setTimeout(() => {\n                            if (this.CurrentStatus != SpiStatus.Unpaired)\n                            {\n                                // This is non-blocking\n                                this._conn.Connect();\n                            }\n                        }, 5000);\n                    }\n                }\n                else if (this.CurrentFlow == SpiFlow.Pairing)\n                {\n                    this._log.info(\"Lost Connection during pairing.\");\n                    this.CurrentPairingFlowState.Message = \"Could not Connect to Pair. Check Network and Try Again...\";\n                    this._onPairingFailed();\n                    document.dispatchEvent(new CustomEvent('PairingFlowStateChanged', {detail: this.CurrentPairingFlowState}));\n                }\n                break;\n            default:\n                throw new Exception('Unknown state: ' + state);\n        }\n    }\n\n    // <summary>\n    // This is an important piece of the puzzle. It's a background thread that periodically\n    // sends Pings to the server. If it doesn't receive Pongs, it considers the connection as broken\n    // so it disconnects. \n    // </summary>\n    _startPeriodicPing() {\n        this._stopPeriodicPing();\n        this._periodicPingThread = setInterval(() => this._periodicPing(),this._pingFrequency);\n        this._periodicPing();\n    }\n\n    _periodicPing() {\n        // while i'm still connected AND paired...\n        if(this._conn.Connected && this._secrets != null) {\n            this._doPing();\n\n            setTimeout(() => {\n                if (this._mostRecentPingSent != null &&\n                    (this._mostRecentPongReceived == null || this._mostRecentPongReceived.Id != this._mostRecentPingSent.Id))\n                {\n                    this._missedPongsCount += 1;\n\n                    this._log.info(`Eftpos didn't reply to my Ping. Missed Count: ${this._missedPongsCount}/${this._missedPongsToDisconnect}.`);\n\n                    if (this._missedPongsCount < this._missedPongsToDisconnect)\n                    {\n                        this._log.info(\"Trying another ping...\");\n                        this._startPeriodicPing();\n                        return;\n                    }\n\n                    // This means that we have not received a pong for our most recent ping.\n                    // We consider this connection as broken.\n                    // Let's Disconnect.\n                    this._log.info(\"Disconnecting...\");\n                    this._conn.Disconnect();\n                    this._stopPeriodicPing();\n                }\n\n                this._missedPongsCount = 0;\n\n            },this._pongTimeout);\n\n        } else {\n            this._stopPeriodicPing();\n            this._log.info(\"Cancelling periodic ping as were disconnected or not paired\");\n        }\n    }\n\n    // <summary>\n    // We call this ourselves as soon as we're ready to transact with the PinPad after a connection is established.\n    // This function is effectively called after we received the first Login Response from the PinPad.\n    // </summary>\n    _onReadyToTransact()\n    {\n        this._log.info(\"On Ready To Transact!\");\n\n        // So, we have just made a connection, pinged and logged in successfully.\n        this.CurrentStatus = SpiStatus.PairedConnected;\n\n        if (this.CurrentFlow == SpiFlow.Transaction && !this.CurrentTxFlowState.Finished)\n        {\n            if (this.CurrentTxFlowState.RequestSent)\n            {\n                // TH-3A - We've just reconnected and were in the middle of Tx.\n                // Let's get the last transaction to check what we might have missed out on.\n                this.CurrentTxFlowState.CallingGlt();\n                this._callGetLastTransaction();\n            }\n            else\n            {\n                // TH-3AR - We had not even sent the request yet. Let's do that now\n                this._send(this.CurrentTxFlowState.Request);\n                this.CurrentTxFlowState.Sent(`Sending Request Now...`);\n                document.dispatchEvent(new CustomEvent('TxFlowStateChanged', {detail: this.CurrentTxFlowState}));\n            }\n        }\n        else\n        {\n            if (!this._hasSetInfo) { \n                this._callSetPosInfo(); \n            }\n\n            // let's also tell the eftpos our latest table configuration.\n            if(this._spiPat) {\n                this._spiPat.PushPayAtTableConfig();\n            }\n        }\n    }\n\n    _callSetPosInfo()\n    {\n        var setPosInfoRequest = new SetPosInfoRequest(this._posVersion, this._posVendorId, \"js\", this.GetVersion(), DeviceInfo.GetAppDeviceInfo());\n        this._send(setPosInfoRequest.toMessage());\n    }\n\n    // <summary>\n    // When we disconnect, we should also stop the periodic ping.\n    // </summary>\n    _stopPeriodicPing() {\n        if(this._periodicPingThread) {\n            // If we were already set up, clean up before restarting.\n            clearInterval(this._periodicPingThread);\n            this._periodicPingThread = null;\n        }\n    }\n\n    // Send a Ping to the Server\n    _doPing()\n    {\n        var ping = PingHelper.GeneratePingRequest();\n        this._mostRecentPingSent = ping;\n        this._send(ping);\n        this._mostRecentPingSentTime = Date.now();\n    }\n\n    // <summary>\n    // Received a Pong from the server\n    // </summary>\n    // <param name=\"m\"></param>\n    _handleIncomingPong(m)\n    {\n        // We need to maintain this time delta otherwise the server will not accept our messages.\n        this._spiMessageStamp.ServerTimeDelta = m.GetServerTimeDelta();\n\n        if (this._mostRecentPongReceived == null)\n        {\n            // First pong received after a connection, and after the pairing process is fully finalised.\n            if (this.CurrentStatus != SpiStatus.Unpaired)\n            {\n                this._log.info(\"First pong of connection and in paired state.\");\n                this._onReadyToTransact();\n            }\n            else\n            {\n                this._log.info(\"First pong of connection but pairing process not finalised yet.\");\n            }\n        }\n\n        this._mostRecentPongReceived = m;\n        this._log.debug(`PongLatency:${Date.now() - this._mostRecentPingSentTime}`);\n    }\n\n    // <summary>\n    // The server will also send us pings. We need to reply with a pong so it doesn't disconnect us.\n    // </summary>\n    // <param name=\"m\"></param>\n    _handleIncomingPing(m)\n    {\n        var pong = PongHelper.GeneratePongRessponse(m);\n        this._send(pong);\n    }\n\n    // <summary>\n    // Ask the PinPad to tell us what the Most Recent Transaction was\n    // </summary>\n    _callGetLastTransaction()\n    {\n        var gltRequest = new GetLastTransactionRequest();\n        this._send(gltRequest.ToMessage());\n    }\n\n    // <summary>\n    // This method will be called whenever we receive a message from the Connection\n    // </summary>\n    // <param name=\"messageJson\"></param>\n    _onSpiMessageReceived(messageJson)\n    {\n        // First we parse the incoming message\n        var m = Message.FromJson(messageJson.Message, this._secrets);\n        this._log.info(\"Received:\" + m.DecryptedJson);\n\n        if (SpiPreauth.IsPreauthEvent(m.EventName))\n        {\n            this._spiPreauth._handlePreauthMessage(m);\n            return;\n        }\n\n        // And then we switch on the event type.\n        switch (m.EventName)\n        {\n            case Events.KeyRequest:\n                this._handleKeyRequest(m);\n                break;\n            case Events.KeyCheck:\n                this._handleKeyCheck(m);\n                break;\n            case Events.PairResponse:\n                this._handlePairResponse(m);\n                break;\n            case Events.DropKeysAdvice:\n                this._handleDropKeysAdvice(m);\n                break;\n            case Events.PurchaseResponse:\n                this._handlePurchaseResponse(m);\n                break;\n            case Events.RefundResponse:\n                this._handleRefundResponse(m);\n                break;\n            case Events.CashoutOnlyResponse:\n                this._handleCashoutOnlyResponse(m);\n                break;\n            case Events.MotoPurchaseResponse:\n                this._handleMotoPurchaseResponse(m);\n                break;\n            case Events.SignatureRequired:\n                this._handleSignatureRequired(m);\n                break;\n            case Events.AuthCodeRequired:\n                this._handleAuthCodeRequired(m);\n                break;\n            case Events.GetLastTransactionResponse:\n                this._handleGetLastTransactionResponse(m);\n                break;\n            case Events.SettleResponse:\n                this.HandleSettleResponse(m);\n                break;\n            case Events.SettlementEnquiryResponse:\n                this._handleSettlementEnquiryResponse(m);\n                break;\n            case Events.Ping:\n                this._handleIncomingPing(m);\n                break;\n            case Events.Pong:\n                this._handleIncomingPong(m);\n                break;\n            case Events.KeyRollRequest:\n                this._handleKeyRollingRequest(m);\n                break;\n            case Events.CancelTransactionResponse:\n                this._handleCancelTransactionResponse(m);\n                break;\n            case Events.SetPosInfoResponse:\n                this._handleSetPosInfoResponse(m);\n                break;\n            case Events.PayAtTableGetTableConfig:\n                if (this._spiPat == null)\n                {\n                    this._send(PayAtTableConfig.FeatureDisableMessage(RequestIdHelper.Id(\"patconf\")));\n                    break;\n                }\n                this._spiPat._handleGetTableConfig(m);\n                break;\n            case Events.PayAtTableGetBillDetails:\n                this._spiPat._handleGetBillDetailsRequest(m);\n                break;\n            case Events.PayAtTableBillPayment:\n                this._spiPat._handleBillPaymentAdvice(m);\n                break;\n            case Events.PrintingResponse:\n                this._handlePrintingResponse(m);\n                break;\n            case Events.TerminalStatusResponse:\n                this._handleTerminalStatusResponse(m);\n                break;\n            case Events.BatteryLevelChanged:\n                this._handleBatteryLevelChanged(m);\n                break;\n            case Events.Error:\n                this._handleErrorEvent(m);\n                break;\n            case Events.InvalidHmacSignature:\n                this._log.info(\"I could not verify message from Eftpos. You might have to Un-pair Eftpos and then reconnect.\");\n                break;\n            default:\n                this._log.info(`I don't Understand Event: ${m.EventName}, ${m.Data}. Perhaps I have not implemented it yet.`);\n                break;\n        }\n    }\n\n    _onWsErrorReceived(error)\n    {\n        this._log.warn(\"Received WS Error: \" + error.Message);\n    }\n\n    _send(message)\n    {\n        var json = message.ToJson(this._spiMessageStamp);\n        if (this._conn.Connected)\n        {\n            this._log.info(\"Sending: \" + message.DecryptedJson);\n            this._conn.Send(json);\n            return true;\n        }\n        else\n        {\n            this._log.info(\"Asked to send, but not connected: \" + message.DecryptedJson);\n            return false;\n        }\n    }\n\n    ResolveDeviceIpAddress()\n    {\n        if (!this.AutoIpResolutionEnable)\n            return;\n\n        var service = new DeviceIpAddressService();\n\n        service.RetrieveService(this._serialNumber, this._deviceApiKey).then((ip) => \n        {\n            if (ip && ip.Ip)\n            {\n                this.CurrentDeviceStatus = new DeviceIpAddressStatus(ip.Ip, ip.Last_updated);\n            }\n            document.dispatchEvent(new CustomEvent('DeviceIpChanged', {detail: this.CurrentDeviceStatus}));\n        });\n    }\n}\n\nexport {Spi};","import {Spi} from \"./src/Spi.js\";\n\nwindow.Spi = Spi;\n"],"sourceRoot":""}